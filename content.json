{"meta":{"title":"H-web Blog","subtitle":"Hong's Front-End Blog","description":"Hong's Front-End Blog","author":"HS Hong","url":"https://sharryhong.github.io"},"pages":[{"title":"About Me","date":"2016-11-26T09:28:20.000Z","updated":"2016-11-28T04:08:34.015Z","comments":true,"path":"about/index.html","permalink":"https://sharryhong.github.io/about/index.html","excerpt":"","text":"+ Hong’s keyword : 호기심, 탐구, 열정, 여행+ HTML, CSS, SASS, Javascript, jQuery, AngularJS … WoW~!"}],"posts":[{"title":"javascript tabmenu (ES5_prototype class)","slug":"javascript-tabmenu","date":"2016-11-28T04:16:12.000Z","updated":"2016-11-28T04:28:14.710Z","comments":true,"path":"2016/11/28/javascript-tabmenu/","link":"","permalink":"https://sharryhong.github.io/2016/11/28/javascript-tabmenu/","excerpt":"","text":"JavaScript 프로토타입 방식으로 클래스 만들기 실습 - 탭 메뉴 해당 코드가 있는 Github 바로가기 | 결과화면 보기 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 2. 함수 단위 -&gt; 프로토타입 방식 클래스 (function(global, $)&#123;&apos;use strict&apos;;// 인스턴스 생성 var tabTab1 = new TabMenu();var tabTab2 = new TabMenu();// 클래스 생성, 프로퍼티 생성 function TabMenu() &#123; this.$tab = null this.$tabMenus = null; this.$selectMenu = null;&#125;// 메서드 생성, 요소 초기화 TabMenu.prototype.init =function(el)&#123; this.$tab = $(el); this.$tabMenus = this.$tab.find(&apos;li&apos;); console.log(this);&#125;TabMenu.prototype.initEvent = function()&#123; var objThis = this; // 아래에 설명 추가 this.$tabMenus.on(&quot;click&quot;, function()&#123; objThis.setSelectMenu($(this)); &#125;);&#125;TabMenu.prototype.setSelectMenu = function($thisMenu)&#123; if(this.$selectMenu)&#123; this.$selectMenu.removeClass(&apos;select&apos;); &#125; this.$selectMenu = $thisMenu; this.$selectMenu.addClass(&apos;select&apos;);&#125;tabTab1.init(&apos;#tabMenu1&apos;);tabTab1.initEvent();tabTab2.init(&apos;#tabMenu2&apos;);tabTab2.initEvent();&#125;)(this, this.jQuery); 클릭(이벤트) 전 this 는 아래처럼 구성되어 있다. (크롬 개발자도구) 12345678910TabMenu $selectMenu:null $tab:n.fn.init[1] $tabMenus:n.fn.init[6] __proto__: Object constructor:TabMenu() init: function(el) initEvent: function() setSelectMenu: function($thisMenu) __proto__: Object 123456TabMenu.prototype.initEvent = function()&#123; var objThis = this; this.$tabMenus.on(&quot;click&quot;, function()&#123; objThis.setSelectMenu($(this)); &#125;);&#125; 위 코드에서 this.$tabMenus.on(&quot;click&quot;,... 클릭을 하면 this가 클릭한 li요소로 되어버립니다. 따라서 변수 objThis에 본래의 this를 저장하여 objThis.setSelectMenu($(this));로 사용한 것입니다. 연관 사이트JavaScript ES5 Class - 관련 링크 바로가기","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Class","slug":"Class","permalink":"https://sharryhong.github.io/tags/Class/"},{"name":"ES5","slug":"ES5","permalink":"https://sharryhong.github.io/tags/ES5/"},{"name":"prototype","slug":"prototype","permalink":"https://sharryhong.github.io/tags/prototype/"},{"name":"TabMenu","slug":"TabMenu","permalink":"https://sharryhong.github.io/tags/TabMenu/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"javascript class (ES6)","slug":"javascript-class-ES6","date":"2016-11-26T14:04:19.000Z","updated":"2016-11-28T04:28:49.549Z","comments":true,"path":"2016/11/26/javascript-class-ES6/","link":"","permalink":"https://sharryhong.github.io/2016/11/26/javascript-class-ES6/","excerpt":"","text":"업뎃중 ^^ 123456class Polygon &#123; // 클래스 이름 constructor(height, width) &#123; // 생성자 (클래스가 만들어지면서 생성자 자동실행) this.height = height; // 초기화 this.width = width; &#125;&#125; 123var p = new Polygon(); // ReferenceError 호이스팅이 안되므로 에러 class Polygon &#123;&#125; 연관 사이트MDN - JavaScript Class (ES6)","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Class","slug":"Class","permalink":"https://sharryhong.github.io/tags/Class/"},{"name":"ES6","slug":"ES6","permalink":"https://sharryhong.github.io/tags/ES6/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"javascript class (ES5)","slug":"javascript-class","date":"2016-11-26T13:18:00.000Z","updated":"2016-11-28T04:30:27.444Z","comments":true,"path":"2016/11/26/javascript-class/","link":"","permalink":"https://sharryhong.github.io/2016/11/26/javascript-class/","excerpt":"","text":"완전정복 스터디 3권(웹동네)으로 공부 + 코드 리펙토링 중 입니다. :)해당 코드가 있는 Github 바로가기 Class함수가 특정 알고리즘을 포장하는 기술이라면, 클래스는 연관있는 변수와 함수만을 포장하는 기술입니다.클래스로 포장하는 이유는 객체 단위로 코드를 그룹화 하고 재사용하기 위함입니다. ES6에서는 class가 생겼지만 아직 이전 버전으로 개발을 많이 하고 있습니다. JavaScript에서 클래스처럼 사용할 수 있는 방법으로는 리터럴 방식 함수 방식 프로토타입 방식이 있는데 프로토타입 방식을 선호합니다.이유는 아래에 설명하겠습니다. 개념인스턴스 객체함수를 사용하려면 함수호출을 해야하듯, 클래스를 사용하려면 일반적으로 인스턴스를 생성해야 합니다.클래스 : 설계도, 인스턴스 : 설계도대로 만들어진 결과물 1var 인스턴스 = new 클래스이름(); 인스턴스가 만들어지면 클래스에서 포장해 놓은 프로퍼티와 메서드를 사용할 수 있게 됩니다. 프로퍼티 (변수)주로 객체 내부에서 사용하는 일반적인 정보, 객체 내부 함수(메서드)에서 처리한 결과값 저장 메서드 (함수)주로 객체의 프로퍼티 값을 변경하거나 알아내는 기능, 클래스의 기능들 생성자인스턴스가 만들어지면서 자동으로 호출되는 함수생성자의 주 용도는 프로퍼티 초기화 역할 담당 리터럴 방식으로 클래스 만들기123456789101112var 인스턴스 = &#123; 프로퍼티: 초기 값 // 프로퍼티 정의 ... 메서드: function() &#123; // 메서드 정의 ... &#125;, ...&#125;// 객체 외부에서 접근하기 인스턴스.프로퍼티;인스턴스.메서드(); 예 :1$(&quot;p&quot;).css(&quot;color&quot;, &quot;#f00&quot;); $인 함수를 매개변수 값 “p”로 호출$()함수에서 jQuery의 인스턴스를 만들어 리턴해주기 때문에 접근연산자 .를 이용해 jQuery가 제공하는 기능 중 css() 를 호출해 글자색을 변경할 수 있습니다. 특징리터럴 방식에서는 생성자가 존재하지 않습니다.리터럴 방식은 클래스를 정의함과 동시에 자동으로 인스턴스가 만들어집니다.단점 : 인스턴스를 하나만 만들 수 있습니다.주 용도 : 여러 개의 데이터를 묶어 값을 보관하거나 함수의 매개변수 값으로 전달할 때 주로 사용합니다. 123456var $ch = $(&quot;#ch&quot;);$ch.css(&#123; &quot;position&quot;: &quot;absolute&quot;, &quot;top&quot;: 100, &quot;left&quot;: 100&#125;); 함수 방식으로 클래스 만들기1234567891011121314// 일반 함수와 비교하기 위해 클래스이름은 대문자로 시작하도록 한다. (일반적인 규칙)function 클래스이름() &#123; this.프로퍼티 = 초기 값; // 프로퍼티 정의 ... this.메서드 = function() &#123; // 메서드 정의 ... &#125; ...&#125;// 인스턴스 생성var 인스턴스 = new 클래스이름(); // 메서드 호출인스턴스.메서드(); 특징생성자 : 클래스이름 자체가 생성자이며 인스턴스가 생성될 때 자동으로 호출됩니다.장점 : 코드 재사용 가능단점 : 인스턴스마다 메서드가 중복해서 생성됩니다. -&gt; 치명적인 단점 프로토타입 방식으로 클래스 만들기클래스를 만드는 방법 중 가장 강력한 방법jQuery도 프로토타입 방식으로 만들어졌다. 1234567891011121314function 클래스이름() &#123; this.프로퍼티 = 초개 값; ...&#125;// 메서드는 prototype이라는 프로퍼티에 정의한다. 클래스이름.prototype.메서드 = function() &#123; ...&#125;// 인스턴스 생성var 인스턴스 = new 클래스이름();// 메서드 호출인스턴스.메서드(); 특징코드 재사용모든 인스턴스는 prototype에 만들어져 있는 메서드를 공유해서 사용합니다.자바스크립트에서는 prototype을 이용해 상속을 구현합니다. 연관 사이트JavaScript 프로토타입 방식으로 클래스 만들기 실습 - 탭 메뉴","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Class","slug":"Class","permalink":"https://sharryhong.github.io/tags/Class/"},{"name":"ES5","slug":"ES5","permalink":"https://sharryhong.github.io/tags/ES5/"},{"name":"prototype","slug":"prototype","permalink":"https://sharryhong.github.io/tags/prototype/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"01. SASS Satting","slug":"01-sass-satting","date":"2016-11-25T10:07:09.000Z","updated":"2016-11-28T04:08:33.902Z","comments":true,"path":"2016/11/25/01-sass-satting/","link":"","permalink":"https://sharryhong.github.io/2016/11/25/01-sass-satting/","excerpt":"","text":"해당 코드가 있는 Github 바로가기 CSS Preprocessor 인 SASS. 웹 스타일링을 담당하는 CSS를 좀 더 똘똘하게 사용하고 유지보수를 좋게하는 프리프로세서입니다. 설치 및 Sass to CSSSASS는 Ruby 언어 기반이나 느리기 때문에 node sass로 실행합니다. 추후엔 Gulp같은 자동화툴로 관리하도록 합니다. 다운로드 및 설치git bash : 터미널 방식으로 명령어를 사용하여서 Git를 컨트롤 하는 시스템설치 후 파일탐색기 &gt; 해당폴더 &gt; 마우스 오른쪽 &gt; git bush here 를 클릭하여 터미널을 실행시킵니다. node sass 설치12$ npm install node-sass --global 혹은 $ npm i -g node-sass (install global줄여쓴 것) sass -&gt; css로 sass or scss파일을 만들고 저장 후 1$ node-sass -w sass/ -o css/ --source-map css sass폴더내의 sass or scss 파일을 css폴더내의 css파일로 컴파일한다는 뜻sourcemapping이 있어야 개발자도구에서 style.sass이런식으로 표시가 됩니다. css 폴더내에 xxx.css.map 파일이 생깁니다. 배포시엔 map파일을 제외하고 올립니다. sass파일을 수정 후 저장합니다. 자, 이제 sass -&gt; css파일로 컴파일 되었습니다. 이젠 css파일은 건드리지 않고 sass파일로만 작업합니다. 파일 쪼개고 병합하기예를들어 _footer.sass와 같이 _가 붙으면 병합될 파일이므로 컴파일되지 않습니다.style.sass 에서 @import /part/page/footer 이런 식으로 @import 하여 병합시킵니다.@import시 파일이름의 _, .sass, .scss는 생략할 수 있습니다. Sublime Text에서 sass, scss 파일 인지시키기 Sublime Text의 install package에서 syntax highlighting for sass를 설치합니다. 서브라임 텍스트의 오른쪽 하단에서 sass를 선택합니다. 참고 사이트 Sass-lang.com","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"Sass","slug":"Front-End/Sass","permalink":"https://sharryhong.github.io/categories/Front-End/Sass/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"https://sharryhong.github.io/tags/Sass/"},{"name":"CSS","slug":"CSS","permalink":"https://sharryhong.github.io/tags/CSS/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"Sass","slug":"Front-End/Sass","permalink":"https://sharryhong.github.io/categories/Front-End/Sass/"}]}]}