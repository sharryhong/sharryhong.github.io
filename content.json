{"meta":{"title":"H-web Blog","subtitle":"Hong's Web Development Blog","description":"Hong's Web Development - Front-End & Back-End","author":"HS Hong","url":"https://sharryhong.github.io"},"pages":[{"title":"About Me","date":"2016-11-26T09:28:20.000Z","updated":"2017-09-21T07:47:42.218Z","comments":true,"path":"about/index.html","permalink":"https://sharryhong.github.io/about/index.html","excerpt":"","text":"Hong’s keyword : 호기심, 탐구, 열정, 여행, 긍정 에너지지향점 : Front-end와 Back-end의 이해로, 높은 퀄리티의 서비스를 개발하는 프로그래머현재 관심 skill : Java, NodeJS, HTML, CSS, SASS, Javascript, jQuery, AngularJS, SQL, Ionic …"}],"posts":[{"title":"TCP와 HTTP","slug":"cs-tcp-http","date":"2017-09-27T05:41:38.000Z","updated":"2017-09-27T06:04:31.945Z","comments":true,"path":"2017/09/27/cs-tcp-http/","link":"","permalink":"https://sharryhong.github.io/2017/09/27/cs-tcp-http/","excerpt":"","text":"TCP(Transmission Control Protocol)전송 계층(Transport layer)에 위치한다.네트워크의 정보 전달을 통제하는 프로토콜이자 인터넷을 이루는 핵심 프로토콜의 하나웹 브라우저들이 월드 와이드 웹에서 서버에 연결할 때 사용되며, 이메일 전송이나 파일 전송에도 사용된다.근거리 통신망이나 인트라넷, 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 옥텟을 안정적으로, 순서대로, 에러없이 교환할 수 있게 한다. Transport layer계층 구조의 네트워크 구성요소와 프로토콜 내에서 송신자와 수신자를 연결하는 통신 서비스를 제공한다.연결 지향 데이터 스트림 지원, 신뢰성, 흐름 제어, 그리고 다중화와 같은 편리한 서비스를 제공한다. HTTP(Hyper-Text Transfer Protocol) : 포스팅 참고응용 계층(Application layer)에 위치한다.기반이 되는 전송 계층(Transport layer) 프로토콜을 사용하여 호스트 간 연결을 확립한다. 개념적으로 살펴 보면 HTTP, HTTPS, FTP 등의 프로토콜은 TCP/IP 위에서 동작한다고 볼수있다. 데이터 형태tcp : byte array(binary)로 정보를 통신http: String으로 정보를 통신 연결방식tcp : 언제나 서버와 연결되어있어야하며, request 없이도 recevie가 일어난다.http: keep-alive로 지속적인 연결은 가능하지만 기본적으론 close로 되어 있으며, request를 하여야만 recevie가 일어난다. 참고 사이트위키피디아-TCP위키피디아-OSI 7 계층 모형tcp/ip와 http의 차이","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Computer Science","slug":"plus-forWeb/Computer-Science","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Computer-Science/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://sharryhong.github.io/tags/HTTP/"},{"name":"TCP","slug":"TCP","permalink":"https://sharryhong.github.io/tags/TCP/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Computer Science","slug":"plus-forWeb/Computer-Science","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Computer-Science/"}]},{"title":"HTTP(Hyper-Text Transfer Protocol)","slug":"back-protocol","date":"2017-09-27T03:18:39.000Z","updated":"2017-09-27T05:38:56.555Z","comments":true,"path":"2017/09/27/back-protocol/","link":"","permalink":"https://sharryhong.github.io/2017/09/27/back-protocol/","excerpt":"","text":"프로토콜(Protocol))이란?데이터를 어떤 형태로 주고 받을 것인지 정한 규약 HTTP(Hyper-Text Transfer Protocol)란?웹서버(HTTP Server)와 웹브라우저(HTTP Client) 사이에 데이터를 주고 받는 형식즉 인터넷 상에서 데이터를 어떻게 주고 받는지를 정의해 둔 것으로 모든 웹브라우저가 이 방식을 따릅니다. HTTP Request(요청) 형식1234Request-Line CRLF((general header | request header | entity header) CRLF)*CRLFmessage-body 1) Request-Line CRLF 요청 대상을 가리키는 한 줄 문자열을 보낸다. 문법 - 요청형식 공백 요청URI 공백 프로토콜버전 줄바꿈예) GET /pub/WWW/TheProject.html HTTP/1.1 (CRLF) 요청 형식GET : 자원 조회를 요청할 때 사용한다.POST : 자원의 추가, 변경을 요청할 때 사용한다.HEAD : 생성일, 크기 등 자원의 정보만 요청할 때 사용한다.PUT : 자원 추가를 요청할 때 사용한다.DELETE : 자원 제거를 요청할 때 사용한다.기타 OPTIONS, TRACE, CONNECT 등이 있다. 2) 헤더 정보 요청에 대한 부가 설명을 담은 데이터이다. 3가지 종류의 데이터로 구성된다.일반정보(general header) : 요청과 응답에 모두 사용되는 데이터요청정보(request header) : 요청할 때만 전달하는 데이터엔티티정보(entity header) : 보내는 데이터에 대한 정보. 단 POST 요청일 때만 보낸다. 문법 - 헤더명: 값 CRLF예) Host: www.w3.org 3) message-body GET 요청에는 message-body가 없다. POST 요청일 때 message-body가 추가된다. 문법 - 이름=값&amp;이름=값&amp;이름=값예) pageNo=1&amp;pageSize=6&amp;align=desc HTTP Response(응답) 형식1234Status-Line CRLF((general header | response header | entity header) CRLF)*CRLFmessage-body 1) Status-Line CRLF 응답 상태 정보를 표현하는 문자열 한 줄 문법 - 프로토콜버전 공백 상태코드 공백 간단한설명 (CRLF) 예) HTTP/1.1 200 OK 주요 상태 코드와 의미200 : 요청한 자원을 줄 수 있다.301 : 요청한 자원의 주소가 바뀌었다. 다시 요청하라!304 : 요청한 자원이 변경되지 않았다.그러니 웹브라우저가 캐시한 자원을 그냥 사용하라!400 : 요청 형식에 문제가 있다. 올바르게 요청하라!403 : 해당 자원에 대한 요청을 거절한다.404 : 요청한 자원을 못 찾았다. 2) 헤더 정보 응답에 대한 부가 설명을 담은 데이터이다. 3가지 종류의 데이터로 구성된다.일반정보(general header) : 요청과 응답에 모두 사용되는 데이터응답정보(request header) : 응답할 때만 전달하는 데이터엔티티정보(entity header) : 응답 데이터에 대한 정보. 문법 - 헤더명: 값 CRLF예) Server: Apache 3) message-body 웹서버가 웹브라우저에게 응답하는 데이터 보통 HTML이 리턴된다. HTML 외에도 JSON, XML, Plain Text, gif 등 텍스트 데이터에서 바이너리 데이터까지다양한 데이터를 리턴할 수 있다. 잘 정리되어 있는 사이트HTTP 그리고 REST API 다가가기","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Computer Science","slug":"plus-forWeb/Computer-Science","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Computer-Science/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://sharryhong.github.io/tags/HTTP/"},{"name":"Protocol","slug":"Protocol","permalink":"https://sharryhong.github.io/tags/Protocol/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Computer Science","slug":"plus-forWeb/Computer-Science","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Computer-Science/"}]},{"title":"Node.js란","slug":"nodejs01","date":"2017-09-27T02:56:46.000Z","updated":"2017-09-27T07:00:39.030Z","comments":true,"path":"2017/09/27/nodejs01/","link":"","permalink":"https://sharryhong.github.io/2017/09/27/nodejs01/","excerpt":"","text":"Node.jsJavaScript언어로 서버를 만듭니다.속도가 빠릅니다.짧은 코드로 쉽게 서버를 만들 수 있습니다.성능이 뛰어나고 안정성과 보안도 검증된 서버로서 실무에 적합합니다.Node.js를 사용하는 대표기업으로 페이팔, 이베이, 야후 등이 있습니다.","categories":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Nodejs","slug":"Back-End/Nodejs","permalink":"https://sharryhong.github.io/categories/Back-End/Nodejs/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://sharryhong.github.io/tags/node-js/"},{"name":"NVM","slug":"NVM","permalink":"https://sharryhong.github.io/tags/NVM/"}],"keywords":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Nodejs","slug":"Back-End/Nodejs","permalink":"https://sharryhong.github.io/categories/Back-End/Nodejs/"}]},{"title":"Spring Framework_스프링이란?","slug":"server-spring01","date":"2017-09-26T13:51:53.000Z","updated":"2017-09-26T15:03:21.366Z","comments":true,"path":"2017/09/26/server-spring01/","link":"","permalink":"https://sharryhong.github.io/2017/09/26/server-spring01/","excerpt":"","text":"스프링이란? (= 스프링 프레임워크)JAVA언어를 기반으로 다양한 애플리케이션을 제작하기 위한 약속된 프로그래밍 툴동적인 웹 사이트를 개발하기 위한 여러가지 서비스를 제공하는 스프링은국내에서 전자정부 표준 프레임워크 기반 기술로서 쓰이고 있고 자바 개발자들에게 표준 프레임워크가 되었습니다. 스프링 학습 이전에 JAVA언어, JSP, Servlet, MVC등 그리고 HTML, CSS, JavaScript 등의 기본적인 학습이 필요합니다. 특징-스프링은 톰켓을 이용할 수 있으며 코드의 경량화 그리고 개발 중에 테스트가 쉽다는 특징이 있습니다. -경량 컨테이너로서 자바 객체를 직접 관리합니다. 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있습니다. -POJO(Plain Old Java Object) 방식의 프레임워크 -POJO란 일반 클래스를 의미합니다. 즉 특정 인터페이스를 구현하거나 상속받을 필요가 없어 기존의 라이브러리 등을 지원하기 용이하고 객체가 가볍습니다. -기존에는 page controller가 Servlet이었기 때문에 페이지 컨트롤러의 생성을 서블릿 컨테이너가 하였습니다. 이 것을 일반 자바 클래스(POJO)로 전환하면 객체 생성을 개발자가 하게됩니다. 이럴 때 이점은 페이지 컨트롤러가 사용하는 컴포넌트를 페이지 컨트롤러가 관리하는 대신, 외부에서 주입해주기 때문에 대체하기 쉬운 구조가 됩니다. -스프링은 제어 반전(IoC : Inversion of Control)을 지원한다. 컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다. -스프링은 의존성 주입(DI : Dependency Injection)을 지원한다. 각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다. -스프링은 관점 지향 프로그래밍(AOP : Aspect-Oriented Programming)을 지원한다. 따라서 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다. -스프링은 persistence와 관련된 다양한 서비스를 지원한다. MyBATIS나 Hibernate 등 이미 완성도가 높은 데이터베이스 처리 라이브러리와 연결할 수 있는 인터페이스를 제공한다. -스프링은 확장성이 높다. 스프링 프레임워크에 통합하기 위해 간단하게 기존 라이브러리를 감싸는 정도로 스프링에서 사용이 가능하기 때문에 수많은 라이브러리가 이미 스프링에서 지원되고 있고 스프링에서 사용되는 라이브러리를 별도로 분리하기도 용이하다. 참고 사이트위키피디아_스프링프레임워크","categories":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Spring","slug":"Back-End/Spring","permalink":"https://sharryhong.github.io/categories/Back-End/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://sharryhong.github.io/tags/Spring/"},{"name":"Framework","slug":"Framework","permalink":"https://sharryhong.github.io/tags/Framework/"}],"keywords":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Spring","slug":"Back-End/Spring","permalink":"https://sharryhong.github.io/categories/Back-End/Spring/"}]},{"title":"Computer Science기초 - Null","slug":"cs-null","date":"2017-09-21T08:26:43.000Z","updated":"2017-09-22T05:09:45.505Z","comments":true,"path":"2017/09/21/cs-null/","link":"","permalink":"https://sharryhong.github.io/2017/09/21/cs-null/","excerpt":"","text":"Null에 대한 고찰1_ 개발자들의 영원한 숙제, ‘NULL’ 이야기위 포스팅에서는 데이터베이스, C, Java상에서의 Null에 대하여 다루어져있습니다. 2_ JavaScript에서의 null과 undefined데이터타입에 대해 유연한 언어인 자바스크립트에서 Null, Undefined에 관해 다룬 포스팅입니다. 3_ Null과 빈칸변수를 초기화하는 관점에서 바라본 null과 빈칸의 차이를 다룬 QnA입니다. 4_포프TV-Null이란 무엇인가? 이렇게 Null에 대해 고찰해 본 이유는, 최근 누군가가 null에 대해 질문을 하였기 때문입니다.메모리 주소를 가리키는 레퍼런스 변수 값이 null이라는 것은 아무것도 가리키지 않는다. 즉 주소 값이 없다는 걸 의미한다.데이터베이스상에서의 null,그리고 변수 선언시 초기화할 때 null,JavaScript에서는 null이 false로 자동 형변환된다.","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Computer Science","slug":"plus-forWeb/Computer-Science","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Computer-Science/"}],"tags":[],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Computer Science","slug":"plus-forWeb/Computer-Science","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Computer-Science/"}]},{"title":"JDBC 프로그래밍 & java.sql 패키지","slug":"java-jdbc02","date":"2017-06-04T13:23:33.000Z","updated":"2017-09-21T07:47:40.054Z","comments":true,"path":"2017/06/04/java-jdbc02/","link":"","permalink":"https://sharryhong.github.io/2017/06/04/java-jdbc02/","excerpt":"","text":"java.sql 패키지의 주요 인터페이스 (mysql의 경우)java.sql.Driver (=&gt; 구현 com.mysql.jdbc.Driver 클래스)=&gt; JDBC Driver 정보를 제공하는 기능=&gt; DBMS와의 연결을 관리하는 객체를 리턴하는 기능 java.sql.Connection (=&gt; 구현 com.mysql.jdbc.ConnectionImpl 클래스)=&gt; DBMS와 연결을 수행하는 기능=&gt; DBMS에 SQL을 전달할 객체를 리턴하는 기능 java.sql.Statement (=&gt; 구현 com.mysql.jdbc.StatementImpl 클래스)=&gt; SQL을 MySQL 형식에 맞춰서 변환한 다음 서버에 보내는 기능=&gt; 서버가 보낸 결과를 다룰 객체를 리턴하는 기능=&gt; executeQuery() : SELECT 문 실행=&gt; executeUpdate() : INSERT, UPDATE, DELETE 등 DML, DDL 명령문 실행=&gt; executeBatch() : 여러 개의 SQL문을 실행할 때 사용 SELECT, INSERT, UPDATE, DELETE 등 모든 SQL 명령문 실행가능 java.sql.ResultSet (=&gt; 구현 com.mysql.jdbc.ResultSetImpl 클래스)=&gt; DBMS 서버에서 SELECT를 실행한 후 생성된 결과를 가져오는 기능=&gt; next() 서버에서 한 개의 레코드를 가져옴 정상적을 가져왔으면 true를 리턴, 가져올 레코드가 없으면 false를 리턴=&gt; getXxx(컬럼 번호 또는 컬럼명) 서버에서 가져온 레코드의 컬럼 값을 꺼내는 메서드 컬럼의 타입에 따라 호출하는 메서드가 다름 숫자 -&gt; getInt() 문자열 -&gt; getString() 날짜 -&gt; getDate() 등 JDBC 프로그래밍 예외처리, 특정 DBMS에 종속되는 것을 막는 등의 코드 리펙토링이 필요하지만, 기본 개념을 위해 작성하였습니다. 1) MySQL JDBC 드라이버의 정보를 다루는 객체를 생성합니다.1com.mysql.jdbc.Driver mysqlDriver = new com.mysql.jdbc.Driver(); 이 객체가 있어야만 MySQL DBMS에 연결할 수 있습니다.com.mysql.jdbc.Driver는 java.sql.Driver 인터페이스에 따라 만들어져 있습니다. 2) MySQL JDBC 드라이버를 “드라이버 관리자”에 등록합니다.1DriverManager.registerDriver(mysqlDriver); 3) 드라이버 관리자를 통해 DBMS와 연결합니다.1234java.sql.Connection con = DriverManager.getConnection( &quot;jdbc:mysql://localhost:3306/dbname&quot;, /* 연결할 DBMS와 데이터베이스 정보 */ &quot;userid&quot;, &quot;password&quot;); 4) SQL을 실행할 Statement 객체 얻기1java.sql.Statement stmt = con.createStatement(); java.sql.Statement 규격에 따라 만든 객체를 리턴합니다.Statement 객체가 SQL 문을 DBMS에 보내는 일을 합니다. 5) SELECT SQL문을 DBMS에 보냅니다.1java.sql.ResultSet rs = stmt.executeQuery(&quot;select mno, name, tel, email from memb&quot;); executeQuery() : 서버가 SELECT를 실행한 후 준비한 결과 값을 가져오는 객체를 리턴하는데, java.sql.ResultSet 규격에 따라 만들어져 있습니다. ResultSet 객체를 통해 서버에 결과를 한 개씩 가져옵니다. (next() 메서드)1234567while (rs.next()) &#123; System.out.printf(&quot;%d, %s, %s, %s\\n&quot;, rs.getInt(&quot;mno&quot;), rs.getString(&quot;name&quot;), rs.getString(&quot;tel&quot;), rs.getString(&quot;email&quot;));&#125; 6) 지금까지 사용한 JDBC 관련 객체의 자원을 생성된 역순으로 해제시킵니다.123rs.close(); // ResultSet 자원 해제stmt.close(); // Statement 자원 해제con.close(); // DBMS와 연결을 끊고 싶다면 Connection의 close()를 호출합니다.","categories":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Java","slug":"Back-End/Java","permalink":"https://sharryhong.github.io/categories/Back-End/Java/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://sharryhong.github.io/tags/JDBC/"}],"keywords":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Java","slug":"Back-End/Java","permalink":"https://sharryhong.github.io/categories/Back-End/Java/"}]},{"title":"JDBC(Java Database Connectivity)","slug":"java-jdbc","date":"2017-06-04T05:29:07.000Z","updated":"2017-09-21T07:47:40.007Z","comments":true,"path":"2017/06/04/java-jdbc/","link":"","permalink":"https://sharryhong.github.io/2017/06/04/java-jdbc/","excerpt":"","text":"관련 용어ODBC(Open Database Connectivity)데이터베이스에 접근하기 위한 소프트웨어의 표준 규격MySQL, Oracle, MS-SQL 등 DBMS사 마다 달랐던 API를 통일하여 사용하고자 만든 규격입니다. JDBC(Java Database Connectivity)자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API데이터베이스에서 자료를 쿼리하거나 업데이트하는 방법을 제공합니다. Type4 JDBC Driver = DBMS Protocol Driver개발자들이 가장 많이 사용하는 방법으로 JDBC Driver는 DBMS와 직접 소켓 통신을 합니다.각 DBMS사의 전용 프로토콜로 소켓 통신을 하므로, Vender전용 드라이버로서 별도 다운로드가 필요합니다. MySQL JDBC Type 4 드라이버 다운로드1) www.mvnrepository.com 에서 mysql을 검색합니다. 내컴퓨터 mysql버전에 따라 다운로드 받아야 합니다. mysql버전 명령창에서 확인 &gt;mysql --version 5.7.17버전 2) MySQL Connector/J의 Gradle 의존 라이브러리 정보를 복사합니다. mysql버전에 해당하는 MySQL Connector/J » 5.1.42 의 Gradle탭 내용을 복사합니다. 3) build.gradle의 dependencies {} 블록에 붙여 넣습니다. 123dependencies &#123; compile group: &apos;mysql&apos;, name: &apos;mysql-connector-java&apos;, version: &apos;5.1.42&apos;&#125; 4) 명령창 해당 프로젝트 폴더에서 gradle 명령을 실행합니다. &gt; gradle eclipse &lt;== 이클립스 설정 파일(.classpath, .project 등)을 갱신합니다. 5) 이클립스에서 프로젝트 폴더를 “Refresh” 합니다. 6) 드라이버 라이브러리 파일(mysql-connector-java-5.1.42.jar)에 있는 클래스를 로딩해 봅니다. 1234567public class Test01 &#123; public static void main(String[] args) throws Exception &#123; // MySQL JDBC 드라이버의 정보를 다루는 객체를 생성합니다. // =&gt; 이 객체가 있어야만 MySQL DBMS에 연결할 수 있습니다. com.mysql.jdbc.Driver driver = new com.mysql.jdbc.Driver(); &#125;&#125;","categories":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Java","slug":"Back-End/Java","permalink":"https://sharryhong.github.io/categories/Back-End/Java/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://sharryhong.github.io/tags/JDBC/"}],"keywords":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Java","slug":"Back-End/Java","permalink":"https://sharryhong.github.io/categories/Back-End/Java/"}]},{"title":"Servlet","slug":"java-servlet","date":"2017-06-03T14:19:00.000Z","updated":"2017-09-21T07:47:40.085Z","comments":true,"path":"2017/06/03/java-servlet/","link":"","permalink":"https://sharryhong.github.io/2017/06/03/java-servlet/","excerpt":"","text":"웹 애플리케이션의 구성요소 3가지는1) 서블릿(servlet) : 클라이언트의 요청을 처리합니다.2) 필터(filter) : 서블릿을 실행하기 전이나 후에 작업을 수행합니다.3) 리스너(listener) : 서블릿 컨테이너의 특정 상황(event)에서 작업하는 객체입니다. 이 중 서블릿(servlet)에 대해 알아보겠습니다. 서블릿이란?웹 애플리케이션은 한 개 이상의 서블릿으로 구성되어 있습니다.서블릿이란 서버에서 실행하는 작은 프로그램 조각(Server Application let(한 조각))이라는 의미로, 동적 자원(Dynamic Resource)을 생성합니다. 이를 위해 자바 웹 애플리케이션 구조(Java Web Application Architecture)를 간단히 살펴보면, 위 그림 중 HTTP Server + Servlet Container = WAS(Web Application Server)입니다.톰켓 서버도 두 기능을 탑재하고 있지만, 대체로 HTTP Server는 좀 더 성능이 뛰어난 Apache 등으로 대체해서 사용합니다. HTTP Server에서는 웹 애플리케이션의 정적 자원(Static Resource) 즉, HTML, CSS, JavaScript, gif등 변하지 않는 자원을 클라이언트 요청에 따라 그대로 읽어서 전달해줍니다. 반면 Servlet Container는 웹 애플리케이션의 동적 자원(Dynamic Resource) 즉, JSP, Servlet등을 생성합니다.오늘의 주인공 서블릿이 등장했습니다. :)쉽게 말하면, 웹 애플리케이션을 구성하는 로그인, 로그아웃, 장바구니 등 이 모두가 하나의 서블릿입니다. 서블릿을 생성하기 위해서는 javax.servlet.Servlet 인터페이스 규칙에 따라 구현해야합니다.서블릿을 만드는 3가지 방법은 다음 포스팅으로.. ^^","categories":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Java","slug":"Back-End/Java","permalink":"https://sharryhong.github.io/categories/Back-End/Java/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://sharryhong.github.io/tags/Servlet/"}],"keywords":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Java","slug":"Back-End/Java","permalink":"https://sharryhong.github.io/categories/Back-End/Java/"}]},{"title":"Tomcat server directory (디렉토리, 폴더) 설명","slug":"back-tomcat01","date":"2017-06-03T13:37:13.000Z","updated":"2017-09-26T14:49:58.930Z","comments":true,"path":"2017/06/03/back-tomcat01/","link":"","permalink":"https://sharryhong.github.io/2017/06/03/back-tomcat01/","excerpt":"","text":"웹 애플리케이션 서버(WAS. Web Application Server)인 톰켓의 디렉토리 구조를 설명하려고 합니다.다른 웹 애플리케이션 서버 프로그램들의 디렉토리 구조도 비슷하다고 하니 잘 알아두면 좋것쥬~ 그동안 서버사이드 공부를 하면서 블로그 포스팅을 못했는데, 이제부터 천천히라도다시 시작하려합니다. :) 씐나!! 제 컴퓨터에 설치된 톰켓의 디렉토리 구조입니다. bin/톰켓 서버 실행과 관련된 쉘 스크립트 파일(.sh, bat등)을 모아둔 곳으로윈도우즈의 경우 startup.bat파일을 더블클릭하여 톰캣서버를 가동시킬 수 있습니다.물론 명령창으로 실행할 수 있습니다. conf/ 톰켓 서버를 실행할 때 참조할 설정파일을 모아둔 곳입니다. lib/톰켓 서버를 구성하는 자바 클래스 라이브러리들을 모아둔 곳입니다. logs/톰켓 서버를 실행하는 동안 실행 또는 오류 정보를 기록한 파일을 모아둔 곳으로서,언제 누가 접속했는지, get, post요청을 했는지, ip address 등이 세세히 기록됩니다. temp/톰켓 서버가 실행하는 동안 임시 데이터를 보관하는 폴더입니다. wepapps/웹 애플리케이션을 모아둔 곳입니다. work/톰켓 서버가 JSP를 실행할 때 그 중간 파일을 보관하는 곳입니다.","categories":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"기타","slug":"Back-End/기타","permalink":"https://sharryhong.github.io/categories/Back-End/기타/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://sharryhong.github.io/tags/Tomcat/"},{"name":"directory","slug":"directory","permalink":"https://sharryhong.github.io/tags/directory/"},{"name":"folder","slug":"folder","permalink":"https://sharryhong.github.io/tags/folder/"}],"keywords":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"기타","slug":"Back-End/기타","permalink":"https://sharryhong.github.io/categories/Back-End/기타/"}]},{"title":"GitHub page로 블로그 만들기 - hexo","slug":"link-hexo","date":"2017-06-03T07:15:49.000Z","updated":"2017-09-21T07:47:41.702Z","comments":true,"path":"2017/06/03/link-hexo/","link":"","permalink":"https://sharryhong.github.io/2017/06/03/link-hexo/","excerpt":"","text":"Github 페이지로 블로그를 만들어보고 싶어 고민할 때, 유명한 Jekyll을 사용하고 싶었습니다.그러나 (역시나? 왜?) Windows에서는 지킬설치시 각종 이슈가 발생한다는 소문이 있더군요..껄껄그래서 찾아낸 hexo! 도움받은 사이트링크입니다. ^^ hexo 한국어사이트 바로가기 hexo 설치시 도움받은 블로그","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://sharryhong.github.io/tags/hexo/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}]},{"title":"MongoDB Window 설치","slug":"database-mongodb","date":"2017-03-03T14:32:03.000Z","updated":"2017-09-21T07:47:39.925Z","comments":true,"path":"2017/03/03/database-mongodb/","link":"","permalink":"https://sharryhong.github.io/2017/03/03/database-mongodb/","excerpt":"","text":"React 스터디를 진행하면서 윈도우유저들은 몽고디비를 먼저 설치해보라는 명이 떨어졌습니다. ㅋㅋ왜 맥에서는 쉽게 설치가 되는 것들이 윈도우에서는 약간?의 말썽이 일어나는 것일까요. 크~도움받은 사이트와 진행을 쉽게 정리해보고자 합니다. 1_ 설치 (참고사이트) mondodb.com 에서 msi파일을 다운로드 받습니다.저는 첫번째인 Windows Server 2008 R2 64-bit and later, with SSL support x64 를 다운받았습니다. msi파일을 실행하면 잘 설치됩니다. 저의 경우 C:\\Program Files\\MongoDB\\Server\\3.4\\bin의 경로에 설치되었습니다. 2_ 환경변수 등록 (참고사이트) 제어판 -&gt; 시스템 및 보안 -&gt; 시스템에서 고급 시스템 설정 탭 -&gt; 환경 변수를 클릭합니다. 새로 만들기 클릭12변수이름 : MONGODB_HOME변수 값 : C:\\Program Files\\MongoDB\\Server\\3.4 3_ DB가 저장되는 기본폴더를 만들어줍니다. cmd를 실행시키고, mkdir c:\\data\\db 로 폴더를 만들어줍니다. 4_ MongoDB 서버를 실행합니다. cmd에서 &quot;C:\\Program Files\\MongoDB\\Server\\3.4\\bin\\mongod.exe&quot; 서버가 실행됩니다. 5_ MongoDB가 잘 동작하는지 확인합니다. cmd에서 &quot;C:\\Program Files\\MongoDB\\Server\\3.4\\bin\\mongo.exe&quot; test 데이터베이스에 연결됩니다.","categories":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Database","slug":"Back-End/Database","permalink":"https://sharryhong.github.io/categories/Back-End/Database/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://sharryhong.github.io/tags/MongoDB/"}],"keywords":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Database","slug":"Back-End/Database","permalink":"https://sharryhong.github.io/categories/Back-End/Database/"}]},{"title":"JavaScript ES6 문법 - default parameter","slug":"javascript-ex6-default-parameter","date":"2017-02-28T16:10:19.000Z","updated":"2017-09-21T07:47:41.123Z","comments":true,"path":"2017/03/01/javascript-ex6-default-parameter/","link":"","permalink":"https://sharryhong.github.io/2017/03/01/javascript-ex6-default-parameter/","excerpt":"","text":"default parameter아래 함수처럼 파라미터 개수에 맞지 않게 함수를 실행시킨다면 오류를 발생시킵니다.1234const sum = function(x,y)&#123; return x+y;&#125;sum(); // NaN ES6에서는 파라미터에 기본 값을 할당해줄 수 있습니다.1234const sum2 = function(x=5,y=10)&#123; return x+y;&#125;sum2(); // 15 각 파라미터는 내부에서 let과 동일하게 동작하기 때문에 TDZ가 존재합니다.TDZ에 관한 포스팅12345function multiply(x = y * 3, y)&#123; console.log(x * y);&#125;multiply(2, 3); // 6multiply(undefined,2); // 레퍼런스 에러. TDZ. 예 : 기본을 GET방식으로 지정해주고자 할 때123456function makeAjaxRequest(url, method = &apos;GET&apos;)&#123; return method;&#125;makeAjaxRequest(&apos;google.com&apos;);makeAjaxRequest(&apos;google.com&apos;, &apos;POST&apos;); 예 : user에게 id를 부여하기. admin user에게는 id를 부여하는 것이 default로 적용되게 할 때123456789101112131415161718192021// 생성자 함수function User(id)&#123; this.id = id;&#125;function generateId()&#123; return Math.random() * 999999; // 유니크한 id생성&#125;// Admin user생성을 위해서는 먼저 user로 생성되어야한다.// 이를 위해 default parameter 사용function createAdminUser(user = new User(generateId()))&#123; user.admin = true; return user;&#125;// 일반 user. 인스턴스 객체 생성, id부여const user = new User(generateId());// admin user. createAdminUser(user); 참고 자료고무곰님 블로그Udemy - ES6 Javascript: The Complete Developer’s Guide ES6 포스팅변수선언 let, constBlocks and IIFEsStrings 문자열표기법 등Arrow functionsClassrest parameterspread operatordefault parameter","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sharryhong.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"default parameter","slug":"default-parameter","permalink":"https://sharryhong.github.io/tags/default-parameter/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"JavaScript ES6 문법 - spread operator","slug":"javascript-ex6-spread-operator","date":"2017-02-26T15:26:16.000Z","updated":"2017-09-21T07:47:41.218Z","comments":true,"path":"2017/02/27/javascript-ex6-spread-operator/","link":"","permalink":"https://sharryhong.github.io/2017/02/27/javascript-ex6-spread-operator/","excerpt":"","text":"spread operator(...)copy목적으로 씁니다.length를 갖고 있는, 즉 순회를 할 수 있는 대상들(배열, 문자열)에 적용가능합니다. 12345678const defaultColors = [&apos;red&apos;, &apos;green&apos;];const userFavoriteColors =[&apos;yellow&apos;, &apos;orange&apos;];// ES5defaultColors.concat(userFavoriteColors); // [&quot;red&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;orange&quot;]// ES6[ ...defaultColors, ...userFavoriteColors, &apos;blue&apos; ]; // [&quot;red&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;orange&quot;,&quot;blue&quot;] rest parameter와 함께 사용 12345678function shoppingList(...items)&#123; if(items.indexOf(&apos;milk&apos;) &lt; 0)&#123; // milk가 없다면 return [&apos;milk&apos;, ...items]; // [&quot;milk&quot;,&quot;bread&quot;,&quot;eggs&quot;] 반환 &#125; return items;&#125;shoppingList(&apos;bread&apos;, &apos;eggs&apos;); ES6 포스팅변수선언 let, constBlocks and IIFEsStrings 문자열표기법 등Arrow functionsClassrest parameterspread operatordefault parameter","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sharryhong.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"spread operator","slug":"spread-operator","permalink":"https://sharryhong.github.io/tags/spread-operator/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"JavaScript ES6 문법 - rest parameter","slug":"javascript-ex6-restparameter","date":"2017-02-26T13:55:00.000Z","updated":"2017-09-21T07:47:41.171Z","comments":true,"path":"2017/02/26/javascript-ex6-restparameter/","link":"","permalink":"https://sharryhong.github.io/2017/02/26/javascript-ex6-restparameter/","excerpt":"","text":"rest parameter(나머지 파라미터 ...)일정하지 않은 갯수의 파라미터를 넘길 때 유용합니다. 1234567function addNum(...numbers) &#123; return numbers.reduce((sum, number) =&gt; &#123; return sum + number; &#125;, 0);&#125;addNum(1,2,3,4,5); arguments와 비교해보면 rest parameter의 장점이 드러납니다. ES5이하 1234567function arr() &#123; console.log(arguments); // 유사배열인 [1,2,3,4,5,true,null,undefined] var arg = Array.prototype.slice.call(arguments, 2); console.log(arg); // [3,4,5,true,null,undefined]&#125;arr(1,2,3,4,5,true,null,undefined); 이렇게 유사배열을 배열로 사용하려면 Array.prototype.slice.call 방식을 사용했습니다. ES6 12345function arr(x , y, ...rest) &#123; console.log(rest);&#125;arr(1,2,3,4,5,true,null,undefined); rest parameter방식을 사용하면 유사배열이 아닌 실제 배열로 반환합니다. [3,4,5,true,null,undefined] ES6 포스팅변수선언 let, constBlocks and IIFEsStrings 문자열표기법 등Arrow functionsClassrest parameterspread operatordefault parameter","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sharryhong.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"rest parameter","slug":"rest-parameter","permalink":"https://sharryhong.github.io/tags/rest-parameter/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"JavaScript Array - find, every, some, reduce 내장 메소드","slug":"javascript-array03","date":"2017-02-13T07:48:40.000Z","updated":"2017-09-21T07:47:40.290Z","comments":true,"path":"2017/02/13/javascript-array03/","link":"","permalink":"https://sharryhong.github.io/2017/02/13/javascript-array03/","excerpt":"","text":"반복자 함수 2. find, every, some, reduce (추후 추가)목차find 메소드 find 메소드콜백함수가 요구하는 조건을 만족하는 첫번째 값을 하나 반환합니다. 없으면 undefined를 반환합니다. 1arr.find(callback[, thisArg]) 예: 특정 프로퍼티, 값을 가지는 첫번재 객체를 찾는 함수를 완성해보세요.주어진 문제 :12345678910var ladders = [ &#123; id: 1, height: 20 &#125;, &#123; id: 3, height: 25 &#125;];function findWhere(array, criteria) &#123; // array 중에서 criteria 에 해당하는 첫번째 객체를 찾아 반환하는 함수 만들기&#125;findWhere(ladders, &#123; height: 25 &#125;); result: { id:3, height: 25 } 이어야 합니다. 나의 문제 풀이 :1234567891011function findWhere(array, criteria) &#123; var key = Object.keys(criteria)[0]; // criteria = &#123; height: 25 &#125; // Object.keys(criteria)[0] = height return array.find(function(arr)&#123; // ladders의 height값이 25인 것을 찾아 반환한다. return arr[key] === criteria[key]; &#125;);&#125; Object.keys(obj) : obj에 들어가는 객체의 프로퍼티 name들을 배열로 반환합니다. (목차로 돌아가기)","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Array","slug":"Array","permalink":"https://sharryhong.github.io/tags/Array/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"JavaScript Array - forEach, map, filter 내장 메소드","slug":"javascript-array02","date":"2017-02-13T04:54:50.000Z","updated":"2017-09-21T07:47:40.239Z","comments":true,"path":"2017/02/13/javascript-array02/","link":"","permalink":"https://sharryhong.github.io/2017/02/13/javascript-array02/","excerpt":"","text":"반복자 함수 1. forEach, map, filter목차forEach 메소드map 메소드filter 메소드 forEach 메소드배열의 각 요소에 대해 한번씩 순서대로 콜백함수를 실행합니다. 1arr.forEach(callback[, thisArg]) callback 함수 : 배열의 각 요소에 대해 실행할 함수로 다음 세 가지 인수를 가집니다.1) currentValue : 배열의 요소 중, 현재 처리되고 있는 요소2) index : 현재 처리되는 요소의 배열 내 인덱스3) array : forEach 메소드가 적용되는 본래 배열 thisArg : 선택항목. callback을 실행할 때 this로 사용되는 값. 예) forEach를 사용하여 images 각 요소의 areas(넓이) = height * width 를 계산하여 areas 배열에 넣어보세요.123456var images = [ &#123; height: 10, width: 30 &#125;, &#123; height: 20, width: 90 &#125;, &#123; height: 54, width: 32 &#125;];var areas = []; forEach 메소드를 사용함으로서 좀 더 명시적으로 코드구현을 할 수 있습니다.12345function imgErea(img) &#123; areas.push(img.height * img.width);&#125;images.forEach(imgErea); (목차로 돌아가기) map 메소드배열의 각각의 요소에 대해 한번씩 순서대로 콜백함수를 실행하고, 그 결과를 모아서 새로운 배열을 반환합니다. 1arr.map(callback[, thisArg]) callback 함수 : 새로운 배열 요소를 생성하는 함수로 다음 세 가지 인수를 가집니다.1) currentValue : 배열의 요소 중, 현재 처리되고 있는 요소2) index : 현재 처리되는 요소의 배열 내 인덱스3) array : map 메소드가 적용되는 본래 배열 thisArg : 선택항목. callback을 실행할 때 this로 사용되는 값. 기본값은 Window 객체. 123456789var ages = [10, 21, 17, 34, 19];var adult = ages.map(function(age)&#123; return age &gt;= 18;&#125;);console.log(adult);// 결과[false, true, false, true, true] 예) map을 사용하여 css속성과 값이 객체로 담겨져 있는 배열에서, 해당 css 속성 값만 저장하는 배열을 만들어보세요.매개변수 1 : css 속성과 값이 객체로 담겨져 있는 배열, 매개변수 2 : css 속성 12345678910111213var paints = [ &#123; color: &apos;red&apos; &#125;, &#123; color: &apos;blue&apos; &#125;, &#123; color: &apos;yellow&apos; &#125;];function pluck(array, property) &#123; var proValue = array.map( (obj) =&gt; &#123; return obj[property]; &#125;); return proValue;&#125;pluck(paints, &apos;color&apos;); // returns [&apos;red&apos;, &apos;yellow&apos;, &apos;blue&apos;]; (목차로 돌아가기) filter 메소드배열 내 각 요소에 대해 제공된 콜백함수에서 true를 반환하는 모든 값이 있는 새로운 배열을 반환합니다.즉, 콜백 테스트를 통과한 배열 요소만 반환되고, 통과하지 못한 배열 요소는 건너뛰어 새로운 배열에 포함되지 않습니다. 1var new_array = arr.filter(callback[, thisArg]) callback 함수 : 배열의 각 요소에 대해 실행할 함수로 다음 세 가지 인수를 가집니다.1) currentValue : 배열의 요소 중, 현재 처리되고 있는 요소2) index : 현재 처리되는 요소의 배열 내 인덱스3) array : filter 메소드가 적용되는 본래 배열 thisArg : 선택항목. callback을 실행할 때 this로 사용되는 값.return값 : 테스트를 통과한 요소가 있는 새로운 배열 예) 댓글의 postId와 포스팅 id가 같은 것 걸러내기123456789101112131415var post = &#123; id: 5, title: &apos;for front-end&apos; &#125;;var comments = [ &#123; postId: 4, content: &apos;JavaScript first and web framework&apos; &#125;, &#123; postId: 5, content: &apos;HTML, CSS&apos; &#125;, &#123; postId: 5, content: &apos;server&apos; &#125;];function commentsPost(post, comments) &#123; return comments.filter(function(comment) &#123; return comment.postId === post.id; &#125;);&#125;commentsPost(post, comments);// [&#123;&quot;postId&quot;:5,&quot;content&quot;:&quot;HTML, CSS&quot;&#125;,&#123;&quot;postId&quot;:5,&quot;content&quot;:&quot;server&quot;&#125;] (목차로 돌아가기) 연관 포스팅JavaScript Array 내장 프로퍼티, 메소드","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Array","slug":"Array","permalink":"https://sharryhong.github.io/tags/Array/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"스터디그룹모임 - JavaScript의 this","slug":"javascript-study03","date":"2017-02-12T09:07:05.000Z","updated":"2017-09-21T07:47:41.599Z","comments":true,"path":"2017/02/12/javascript-study03/","link":"","permalink":"https://sharryhong.github.io/2017/02/12/javascript-study03/","excerpt":"","text":"이번주에 우리 스터디모임에서 나눈 주제는 크로스브라우징, JS ES6 - Arrow Function, 원시데이터와 참조데이터였습니다.Arrow Function에 대해서는 제가 발표자였는데, JavaScript의 this에 대해 좀 더 자세하게 다뤄야할 필요성이 느껴지더라고요. 잘 알고있다고 생각했는데 클래스, 인스턴스, 메소드 등의 this에 대해서 정리가 필요할 것 같았습니다. this란?일반적으로 메소드를 호출한 객체가 저장되어 있는 속성입니다.하지만 JavaScript의 this 속성은 메소드를 호출할 때 뿐 아니라, 일반 함수를 호출할 때, 이벤트 리스너가 호출될 때, 중첩 함수에서 등에서의 this가 달라지게 됩니다.간단하게 표로 나타내면.. this가 만들어지는 경우 this 값 1_일반 함수 window 2_중첩 함수 window 3_이벤트 이벤트를 발생시킨 객체 4_메소드 메소드를 호출한 객체 5_메소드 내부의 중첩함수 window 1_일반 함수에서의 this참고 자료웹 프론트엔드 개발자를 위한, 자바스크립트+jQuery 완전정복 스터디 - 김춘경(딴동네)","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"this","slug":"this","permalink":"https://sharryhong.github.io/tags/this/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"JavaScript ES6 문법 - class","slug":"javascript-es6-class","date":"2017-02-06T08:05:37.000Z","updated":"2017-09-21T07:47:40.934Z","comments":true,"path":"2017/02/06/javascript-es6-class/","link":"","permalink":"https://sharryhong.github.io/2017/02/06/javascript-es6-class/","excerpt":"","text":"Class 클래스자바스크립트 ES5 문법으로 class를 만들기 위해서 prototype 상속을 이용하는 방법을 사용하였습니다. 해당 포스팅 바로가기ES6 문법에서는 class 문법을 지원함으로서 이를 좀 더 쉽게 만들게 해줍니다. ES5 와 ES6 비교1_ ES5123456789101112131415// Person 클래스. 생성자 함수var Person = function(name, yearofBirth, job) &#123; // 프로퍼티 this.name = name; this.yearofBirth = yearofBirth; this.job = job;&#125;// 메소드Person.prototype.calculateAge = function() &#123; var age = new Date().getFullYear() - this.yearofBirth; console.log(age);&#125;// 클래스 인스턴스var john = new Person(&apos;John&apos;, 1980, &apos;teacher&apos;);john.calculateAge(); 2_ES612345678910111213141516171819// Person 클래스class Person &#123; // 생성자 메소드 : 초기 프로퍼티 설정 constructor (name, yearofBirth, job) &#123; // 프로퍼티 this.name = name; this.yearofBirth = yearofBirth; this.job = job; &#125; // 메소드 calculateAge() &#123; let age = new Date().getFullYear() - this.yearofBirth; console.log(age); &#125;&#125;// 클래스 인스턴스let john = new Person(&apos;John&apos;, 1980, &apos;teacher&apos;);john.calculateAge(); static 메소드 : 클래스 인스턴스에 의해 상속되지 않는 메소드12345678910111213// 클래스 내부에서class Person &#123; // static 메소드 static greeting() &#123; console.log(&apos;hi!&apos;); &#125;&#125;// 클래스 인스턴스let john = new Person(&apos;John&apos;, 1980, &apos;teacher&apos;);Person.greeting(); // &apos;hi!&apos;john.greeting(); // error 특징1) class 정의는 호이스팅(hoisting) 되지 않습니다. 따라서 클래스를 먼저 구현하고 사용해야합니다. 2) class에 메소드는 추가할 수 있지만 프로퍼티는 추가할 수 없습니다.객체 인스턴스를 통해 상속된 프로퍼티는 좋은 코드가 아니기 때문에 문제가 되지 않습니다. 상속 구현ES6, ES6모두 prototype 체인의 방법으로 상속이 구현됩니다.ES6에서는 기존 객체지향 언어에서 제공하는 키워드인 class 등을 사용함으로써 좀 더 접근하기 쉬워졌습니다. superclass(수퍼클래스, 부모클래스), subclass(서브클래스, 자식클래스) 1_ ES5 12345678910111213141516171819// 자식클래스var Athlete = function(name, yearofBirth, job, olympics, medals) &#123; Person.call(this, name, yearofBirth, job); this.olympics = olympics; this.medals = medals;&#125;// 상속 구현 1) : Object.create() 사용하는 방법Athlete.prototype = Object.create(Person.prototype);// 상속 구현 2) : 자식클래스의 prototype에 부모클래스의 인스턴스를 대입하는 방법Athlete.prototype = new Person();Athlete.prototype.constructor = Athlete;// 인스턴스var johnAthlete = new Athlete(&apos;John&apos;, 1980, &apos;swimmer&apos;, 3, 10);// 부모클래스의 메소드 사용johnAthlete.calculateAge(); Person.call(this) : 부모클래스인 Person 생성자를 호출합니다.call() - MDN 상속 new와 Object.createObject.create() - MDN 2_ ES6 123456789101112131415161718// 자식클래스class Athlete extends Person &#123; // extends : 상속시 사용하는 키워드 constructor(name, yearofBirth, job, olympics, medals) &#123; // super : call the superclass. 부모의 생성자 호출 super(name, yearofBirth, job); this.olympics = olympics; this.medals = medals; &#125; // Athlete의 메소드 wonMedal() &#123; this.medals++; console.log(this.medals); &#125;&#125;// Athlete의 인스턴스let johnAthlete = new Athlete(&apos;John&apos;, 1980, &apos;swimmer&apos;, 3, 10);// 부모클래스의 메소드 사용johnAthlete.calculateAge(); 위와 같이 ES6에서 class, extends, super 등의 키워드를 제공함으로서 좀 더 편하게 상속 기능을 사용할 수 있습니다. super(); = superclass.constructor() 예제 추가 : Monster Game Class 만들기 Monster 게임의 기본 클래스를 세팅해봅니다.superclass는 Monster이며, 프로퍼티엔 name과 health(체력)이 있습니다.체력은 100으로 초기화합니다. 생성자는 name 프로퍼티를 가진 option 객체로 호출됩니다.subclass에 Snake 라는 클래스를 만듭니다. Snake에는 bite라는 기능(메소드)가 있습니다. 이 메소드의 유일한 인수(argument)는 Snake의 인스턴스입니다. (뱀이 뱀을 물다.) 물릴경우 체력이 -10 됩니다. 12345678910111213141516171819class Monster &#123; constructor(options)&#123; this.name = options.name; // health는 100으로 초기화 되어있다. this.health = 100; &#125;&#125;class Snake extends Monster &#123; // bite 메소드는 Snake class의 인스턴스를 매개변수로 받아 // health값을 -10 한다. bite(snake) &#123; return snake.health -= 10; &#125;&#125;let snake = new Snake(&#123;name: &apos;snakeya&apos;&#125;);snake; // &#123;name: &apos;snakeya&apos;, health: 100&#125;snake.bite(snake); // 90 (snake.healt) 참고 자료Udemy - The Complete JavaScript CourseUdemy - ES6 Javascript: The Complete Developer’s Guide 연관 포스팅JavaScript Class (ES5) ES6 포스팅변수선언 let, constBlocks and IIFEsStrings 문자열표기법 등Arrow functionsClassrest parameterspread operatordefault parameter","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sharryhong.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"class","slug":"class","permalink":"https://sharryhong.github.io/tags/class/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"JavaScript 객체지향 - 캡슐화","slug":"javascript-oop03","date":"2017-02-06T05:54:18.000Z","updated":"2017-09-21T07:47:41.408Z","comments":true,"path":"2017/02/06/javascript-oop03/","link":"","permalink":"https://sharryhong.github.io/2017/02/06/javascript-oop03/","excerpt":"","text":"캡슐화 (encapsulation)객체의 중요한 프로퍼티(데이터)와 메소드(기능)를 외부에서 접근하지 못하게 하는 작업을 말합니다. 일반적으로 객체 내부의 프로퍼티, 메소드는 1)객체 내부, 2)객체 외부, 3)자식 객체에서 접근해 사용합니다. ES5 소스 예시1234567891011121314151617181920// MyParent 클래스function MyParent() &#123; this.property01 = 10;&#125;// 메소드MyParent.prototype.method01 = function() &#123; this.property01 = 100; // 1)객체 내부에서 접근&#125;// 인스턴스 생성var my01 = new MyParent();my01.method01(); // 2)객체 외부에서 접근// MyChild 클래스 function MyChild() &#123;&#125;// 상속MyChild.prototype = new MyParent();MyChild.prototype.method02 = function() &#123; this.method01(); // 3) 자식 객체에서 부모 메소드 접근&#125; 객체지향 프로그래밍 에서 접근 지정자 객체 내부 접근 객체 외부 접근 자식 객체 접근 public O O O protected O X O private O X X 자바스크립트 ES5에서는 위와 같은 접근지정자 문법을 지원하지 않기 때문에 아래와 같이 표현합니다.1234567891011121314function MyClass() &#123; // public 프로퍼티 this.property01 = 10; // private, protected 프로퍼티 this._proterty02 = 20;&#125;// public 메소드MyClass.prototype.method01 = function() &#123;&#125;// private, protected 메소드MyClass.prototype._method02 = function() &#123;&#125; 자바스크립트에서는 public만 지원하기 때문에 위와같이 약속하여 사용할 뿐, 객체 외부에서 접근이 가능합니다.","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"객체지향","slug":"객체지향","permalink":"https://sharryhong.github.io/tags/객체지향/"},{"name":"캡슐화","slug":"캡슐화","permalink":"https://sharryhong.github.io/tags/캡슐화/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"JavaScript 객체지향 - 추상화","slug":"javascript-oop02","date":"2017-02-05T04:43:15.000Z","updated":"2017-09-21T07:47:41.369Z","comments":true,"path":"2017/02/05/javascript-oop02/","link":"","permalink":"https://sharryhong.github.io/2017/02/05/javascript-oop02/","excerpt":"","text":"추상화 (abstraction)객체의 프로퍼티와 메소드를 정의 하는 작업으로, 이름을 작성하는 선언 부분만 만들 뿐 구현부분은 작업하지 않습니다. 자바스크립트에서는 인터페이스와 추상클래스를 제공하지 않기 때문에 클래스만을 이용해서 추상화 작업을 해야합니다. 예: 이미지 슬라이더 추상화 하기 ImgSlider 프로퍼티 현재 선택된 이미지 인덱스 이미지 목록 ImgSlider 메소드 자동 플레이 기능 시작 자동 플레이 기능 멈춤 다음 이미지 이동 이전 이미지 이동 index번째 이미지 이동 위를 소스로 표현하면 (ES5)123456789function ImgSlider(selector) &#123; this.selectIndex; this.imgList;&#125;ImgSlider.prototype.startAutoPlay = function() &#123;&#125;ImgSlider.prototype.stopAutoPlay = function() &#123;&#125;ImgSlider.prototype.nextImg = function() &#123;&#125;ImgSlider.prototype.prevImg = function() &#123;&#125;ImgSlider.prototype.setImgAt = function(index) &#123;&#125; 참고 자료웹 프론트엔드 개발자를 위한, 자바스크립트+jQuery 완전정복 스터디 - 김춘경(딴동네) 관련 포스팅객체지향 프로그래밍 개념","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"객체지향","slug":"객체지향","permalink":"https://sharryhong.github.io/tags/객체지향/"},{"name":"추상화","slug":"추상화","permalink":"https://sharryhong.github.io/tags/추상화/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"스터디그룹모임 - Event(이벤트)","slug":"javascript-study02","date":"2017-02-03T15:59:54.000Z","updated":"2017-09-21T07:47:41.569Z","comments":true,"path":"2017/02/04/javascript-study02/","link":"","permalink":"https://sharryhong.github.io/2017/02/04/javascript-study02/","excerpt":"","text":"설연휴로 인해 2주만에 만난 스터디모임 ^^ 알차고 재밋었던 시간이었습니다~이번엔 이벤트 버블링, 이벤트 객체, 이벤트 위임, ES6, 알고리즘 등을 나눴는데,그 중 이벤트에 대해 포스팅해보려합니다. 이벤트 버블링 (Event Bubbling)이벤트 버블링이란 자식노드에서 부모노드 순으로 이벤트가 전파되는 것으로, 반대방향으로 전파되는 것은 캡쳐링이라고 합니다.일반적으로 이벤트는 버블링됩니다. 이벤트 버블링을 막으려면 stopPropagation() 메소드를 사용해야합니다.123456document.querySelector(&quot;.cbtn&quot;).addEventListener(&quot;click&quot;, doSth);function doSth(e) &#123; e.stopPropagation(); // do something&#125; 이벤트 객체1eventTarget.addEventListener(&quot;click&quot;, function(e)&#123;&#125;); 위의 코드에서 콜백함수의 매개변수로 들어간 e는 이벤트 객체를 말합니다. 이벤트 객체의 주요 프로퍼티와 메소드event.target : 현재 이벤트가 발생한 요소event.currentTarget : 현재 이벤트가 발생한 DOM요소로 일반적으로 this와 같습니다.event.preventDefault() : 현재 이벤트의 기본 동작을 중단합니다.event.stopPropagation(); : 현재 이벤트가 상위로 전파되지 않도록 중단합니다. 이벤트 위임 (Event Delegation)위에서 살펴봤듯이 이벤트는 기본적으로 버블링되어 전파됩니다.이런 성질을 이용해서 자식 요소가 자주 바뀌거나 너무 많을 경우, 공통된 부모 요소에 이벤트를 걸어두고 처리하는 방법을 말합니다.","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"이벤트 버블링","slug":"이벤트-버블링","permalink":"https://sharryhong.github.io/tags/이벤트-버블링/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"JavaScript ES6 문법 - Strings 문자열표기법 등","slug":"javascript-es6-string","date":"2017-02-03T00:25:41.000Z","updated":"2017-09-21T07:47:40.986Z","comments":true,"path":"2017/02/03/javascript-es6-string/","link":"","permalink":"https://sharryhong.github.io/2017/02/03/javascript-es6-string/","excerpt":"","text":"Template StringsES5에서 문자열을 변수, 함수와 함께 쓰고자 할 때 +기호를 씁니다.12345678910let firstName = &apos;John&apos;;let lastName = &apos;Smith&apos;;const yearOfBirth = 1990;function calcAge(year) &#123; return 2017 - year;&#125;// ES5console.log(&apos;This is &apos; + firstName + &apos; &apos;+ lastName +&apos;. He was born in &apos; + yearOfBirth + &apos;. Today, he is &apos; + calcAge(yearOfBirth) + &apos; years old.&apos;); 이처럼 때로는 번거롭게 코딩해야하는데요, ES6에서는 ${value(변수, 함수 등)}를 제공함으로서 보다 편리하게 코딩할 수 있습니다.12// ES6console.log(`This is $&#123;firstName&#125; $&#123;lastName&#125;. He was born in $&#123;yearOfBirth&#125;. Today, he is $&#123;calcAge(yearOfBirth)&#125; years old.`); String 메소드들1234567const fullName = `$&#123;firstName&#125; $&#123;lastName&#125;`;console.log(fullName.startsWith(&apos;J&apos;)); // trueconsole.log(fullName.endsWith(&apos;th&apos;)); // trueconsole.log(fullName.includes(&apos; &apos;)); // trueconsole.log(fullName.repeat(3)); // John SmithJohn SmithJohn Smithconsole.log(`$&#123;fullName&#125;, `.repeat(3)); // John Smith, John Smith, John Smith, String.prototype.startsWith()특정 문자열로 시작하는지 확인하여 맞으면 true, 틀리면 false를 반환합니다. String.prototype.endsWith()특정 문자열로 끝나는지 확인하여 맞으면 true, 틀리면 false를 반환합니다. String.prototype.includes()특정 문자열을 포함하고 있으면 true, 없으면 false를 반환합니다. String.prototype.repeat()1string.repeat(count); count 횟수만큼 반복하여 문자열을 반환합니다. ES6 포스팅변수선언 let, constBlocks and IIFEsStrings 문자열표기법 등Arrow functionsClassrest parameterspread operatordefault parameter","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sharryhong.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Strings","slug":"Strings","permalink":"https://sharryhong.github.io/tags/Strings/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"JavaScript ES6 문법 - Blocks and IIFEs","slug":"javascript-es6-blocks","date":"2017-02-02T14:06:03.000Z","updated":"2017-09-21T07:47:40.838Z","comments":true,"path":"2017/02/02/javascript-es6-blocks/","link":"","permalink":"https://sharryhong.github.io/2017/02/02/javascript-es6-blocks/","excerpt":"","text":"Blocks and IIFEsES5 이하에서는 var 변수 선언을 하면 전역변수가 되기 때문에 전역을 오염시키지 않기 위해 IIFE패턴을 썼습니다.1234// ES5(function()&#123; var a = 5;&#125;)(); 그러나 ES6에서 제공하는 let, const 선언은 지역변수이므로, 블록으로 묶어주기만 하면 IIFE패턴을 쓰지 않고도 전역을 오염시키지 않게 됩니다.12345// ES6&#123; const a = 5; let b = 10;&#125; 아주 간단해졌습니다. :) ES6 포스팅변수선언 let, constBlocks and IIFEsStrings 문자열표기법 등Arrow functionsClassrest parameterspread operatordefault parameter","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sharryhong.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"block","slug":"block","permalink":"https://sharryhong.github.io/tags/block/"},{"name":"IIFE","slug":"IIFE","permalink":"https://sharryhong.github.io/tags/IIFE/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"JavaScript 객체지향 프로그래밍","slug":"javascript-oop01","date":"2017-02-02T06:37:21.000Z","updated":"2017-09-21T07:47:41.334Z","comments":true,"path":"2017/02/02/javascript-oop01/","link":"","permalink":"https://sharryhong.github.io/2017/02/02/javascript-oop01/","excerpt":"","text":"스터디 모임 때 객체지향 프로그래밍의 개념에 대해 이야기를 나누었습니다.진행할 프로젝트에서 객체지향으로 짜보고 싶어 좀 더 깊게 공부해보려합니다. 객체지향 프로그래밍(Object-Oriented Programming)절차지향 프로그래밍과 비교해 보자절차지향은 문제를 순차적으로 호출해 처리하는 방식으로, 함수 단위 코딩을 하는 경우가 대표적인 예입니다.전역 데이터를 매개변수 값으로 공유해서 사용하는 구조이기 때문에 데이터가 보호되지 않는다는 치명적인 단점이 있습니다.또한 하나의 프로젝트를 여러사람이 작업할 경우에도 적합하지 않습니다.이러다보니 비교적 간단한 프로젝트에 주로 사용합니다. 객체지향이란?문제를 여러 개의 객체 단위로 나눠 작업하는 방식으로 오늘날 가장 많이 사용하는 대표적인 프로그래밍 방식입니다.객체지향 프로그래밍의 기본 단위는 클래스 단위 프로그래밍으로서클래스를 이용해 연관 있는 데이터부분(변수, 프로퍼티)과 처리부분(함수, 메소드)을 하나로 묶어 객체(인스턴스)를 생성해 사용합니다. 4가지 특징인 추상화, 캡슐화, 상속, 다형성을 골고루 사용해 코딩하는 프로그래밍을 객체지향이라고 합니다.프로그래밍 선배님들이 어떻게 하면 유지보수하기 쉽고 중복되지 않는 멋진 코드를 만들 수 있을까 하고 노력한 끝에 완성한 최상의 결과물! 장점 : 프로젝트를 독립적인 객체 단위로 분리해서 작업할 수 있으므로 여러 개발자와 협업해 규모가 큰 프로젝트를 진행할 수 있습니다. 추상화(abstraction)설계하는 작업 자체를 나타냅니다. 프로퍼티와 메서드를 정의 하는 작업으로 이름을 작성하는 선언 부분만 만들 뿐 소스는 구현하지 않습니다. 캡슐화(encapsulation)어떤 프로퍼티와 메서드는 외부에서 접근가능(public), 외부에서 접근하지 못하게(private) 하는 작업을 말합니다. 상속(inheritance)부모 클래스의 프로퍼티와 메서드를 자식클래스가 물려 받는 것입니다. 즉, 자식클래스에서 부모클래스의 기능을 사용할 수 있습니다. 다형성(polymorphism)객체지향의 핵심입니다. 선언 부분과 구현 부분을 나눠 다양하게 처리할 수 있습니다.다형성을 적용해 코드를 만들게 되면 특정 작업을 소스 수정을 거의 하지 않고 다양한 방법으로 연결해서 만들 수 있습니다. 참고 자료웹 프론트엔드 개발자를 위한, 자바스크립트+jQuery 완전정복 스터디 - 김춘경(딴동네)","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"객체지향","slug":"객체지향","permalink":"https://sharryhong.github.io/tags/객체지향/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"Algorism - 수열의 곱과 합.. 최소값 만들기 (JavaScript)","slug":"algorism15","date":"2017-01-30T04:31:58.000Z","updated":"2017-09-21T07:47:39.838Z","comments":true,"path":"2017/01/30/algorism15/","link":"","permalink":"https://sharryhong.github.io/2017/01/30/algorism15/","excerpt":"","text":"알고리즘 15. 최소값 만들기 (JavaScript) 자연수로 이루어진 길이가 같은 수열 A,B가 있습니다. 최솟값 만들기는 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱한 값을 누적하여 더합니다. 이러한 과정을 수열의 길이만큼 반복하여 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다.예를 들어 A = [1, 2] , B = [3, 4] 라면1) A에서 1, B에서 4를 뽑아 곱하여 더합니다.2) A에서 2, B에서 3을 뽑아 곱하여 더합니다.수열의 길이만큼 반복하여 최솟값 10을 얻을 수 있으며, 이 10이 최솟값이 됩니다.수열 A,B가 주어질 때, 최솟값을 반환해주는 getMinSum 함수를 완성하세요. 나의 코딩1) 우선 배열 값끼리 곱하여 더하기를 반복문을 돌려 구한 뒤 최소값을 구하려고 해보았더니, 배열 index 갯수가 많아지면 복잡해져 다른 방법을 생각해보기로 했습니다. 2) 하나의 배열은 작은 숫자대로 정렬하고, 하나의 배열은 큰 숫자대로 정렬하여 같은 index 값끼리 곱하여 전체를 더해주면 최소값이 나온다는 것을 생각하였습니다. 3) JavaScript의 Array.prototype.sort() 내장 메서드를 사용하여 정렬합니다. 4) 그런데 sort()는 문자열에 따르므로 숫자의 경우 크기대로 정렬이 되지 않습니다.예를 들어 23, 1004의 경우 1004가 앞에 오게 됩니다.레퍼런스를 읽어보니 배열 index 값 앞뒤 비교를 하여12345678910function compare(a, b) &#123; if (a is less than b by some ordering criterion) &#123; return -1; &#125; if (a is greater than b by the ordering criterion) &#123; return 1; &#125; // a must be equal to b return 0;&#125; a(앞 값), b(뒤 값) 비교를 하여 0보다 작으면 a가 작은 값,0보다 크면 b가 작은 값입니다. 이를 간단하게 아래처럼 코딩할 수 있습니다.123function compareNumbers(a, b) &#123; return a - b;&#125; 5) 이렇게 sort()에 대하여 알아보고 코딩해봅니다. 12345678910111213141516function getMinSum(A,B)&#123; var answer = 0; A = A.sort(compareNum); B = B.sort(compareNum).reverse(); var leng = A.length; for( var i = 0; i &lt; leng; i++ ) &#123; answer += A[i] * B[i]; &#125; return answer;&#125;function compareNum(a, b) &#123; return a - b;&#125;getMinSum([189,2309,457,4594,7315,7551,7782,8311,8582,9664],[9624,8663,6130,5866,547,357,3392,3206,3070,302]); 처음엔 sort()가 문자열대로 정렬되어 값이 틀리게 나왔었습니다. 그 후 레퍼런스를 자세히 본 뒤 수정하였습니다.다른분들 풀이를 보니 reverse() 내장메서드를 쓰지 않고 아래처럼 구현하였습니다.12A.sort(function(a,b)&#123;return a-b;&#125;);B.sort(function(a,b)&#123;return b-a;&#125;);","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Algorism","slug":"plus-forWeb/Algorism","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Algorism/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Algorism","slug":"Algorism","permalink":"https://sharryhong.github.io/tags/Algorism/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Algorism","slug":"plus-forWeb/Algorism","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Algorism/"}]},{"title":"Algorism - 약수의 합 (JavaScript)","slug":"algorism14","date":"2017-01-25T07:42:03.000Z","updated":"2017-09-21T07:47:39.794Z","comments":true,"path":"2017/01/25/algorism14/","link":"","permalink":"https://sharryhong.github.io/2017/01/25/algorism14/","excerpt":"","text":"알고리즘 14. 약수의 합 (JavaScript) 어떤 수를 입력받아 그 수의 약수를 모두 더한 수 sumDivisor 함수를 완성해 보세요. 예를 들어 12가 입력된다면 12의 약수는 [1, 2, 3, 4, 6, 12]가 되고, 총 합은 28이 되므로 28을 반환해 주면 됩니다. 약수(divisor)는 어떤 정수를 나누어 떨어지게 하는, 0이 아닌 정수를 말하며,음의 정수도 약수가 되지만 일반적으로 양의 약수만 다룹니다. 나의 코딩1) 약수는 나눠 떨어지는 정수를 구하면 됩니다.for문으로 1부터 해당 값까지, % 나머지 값이 0인 값을 구하면 될 것 같습니다. 12345678910111213function sumDivisor(num) &#123; var answer = 0; for(var i = 1; i &lt;= num; i++) &#123; if(num % i === 0) &#123; answer += i; &#125; &#125; return answer;&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(sumDivisor(12)); 생각과 그대로 잘 실행이 되었습니다. ^^","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Algorism","slug":"plus-forWeb/Algorism","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Algorism/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Algorism","slug":"Algorism","permalink":"https://sharryhong.github.io/tags/Algorism/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Algorism","slug":"plus-forWeb/Algorism","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Algorism/"}]},{"title":"Firebase - Realtime Database","slug":"firebase-database","date":"2017-01-25T04:55:09.000Z","updated":"2017-09-21T07:47:39.973Z","comments":true,"path":"2017/01/25/firebase-database/","link":"","permalink":"https://sharryhong.github.io/2017/01/25/firebase-database/","excerpt":"","text":"Firebase on the Web - Firecasts Youtube 실제 데이터를 구현하고 싶은 욕망이 항상 있었는데, 이번 예산관리 웹앱을 만들면서 파이어베이스로 디비구현 및 실제 데이터를 붙여보고 싶었습니다.파이어베이스가 스타트업으로 시작해서 구글에서 인수했다고 들었는데.. 능력자들! firebase로 할 수 있는 것들 (web기준) 인증, 스토리지, 호스팅, firebase 클라우드의 웹푸시 알림 등 Angular 1 &amp; 2, Polymer, React, Ember등의 자바스크립트 프레임워크 연동 Realtime Database - 간단하게 구현해보기Firebase 시작! https://firebase.google.com 간단하게 가입 후 무료로 시작하기, 콘솔로 이동합니다. Create new project 버튼 클릭, project name을 정하고 create project overview창에서 Add Firebase to your web app 클릭하면 시작에 필요한 모델들과 초기화 코드(initialization code)가 나옵니다. html, js에 초기화 코드 넣기1&lt;script src=&quot;https://www.gstatic.com/firebasejs/3.6.6/firebase.js&quot;&gt;&lt;/script&gt; 12345678// Initialize Firebasevar config = &#123;apiKey: &quot;---&quot;,authDomain: &quot;---&quot;,---,storageBucket: &quot;---&quot;,messagingSenderId: &quot;---&quot;&#125;;firebase.initializeApp(config); 이 작업만 하면 기본적인 파이어베이스 세팅이 됩니다. 여기서 잠깐!Windows OS 에서 크롬에서는 overview창이 열리지 않습니다. 아마.. 큰 문제인거 같은데 파이어베이스에서 모르는건지..유투브 댓글을 보니 몇명이 써놨더라고요. 저만 그런지 알고 처음에 당황했는데, 혹시 몰라서 모바일(사파리)과 파이어폭스에서 열어보니 잘됩니다.. ㅋㅋ Realtime Events 목차value eventschild events value events객체, 데이터 등을 동기화시키는 데 좋습니다. 123456789101112131415161718192021(function() &#123; // Initialize Firebase var config = &#123; apiKey: &quot;---&quot;, authDomain: ---&quot;, databaseURL: &quot;---&quot;, storageBucket: &quot;---&quot;, messagingSenderId: &quot;---&quot; &#125;; firebase.initializeApp(config); // get element const preObject = document.getElementById(&apos;object&apos;); // database 참조를 만들어서 data를 실시간으로 동기화해보자. // create references const dbRefObject = firebase.database().ref().child(&apos;object&apos;); dbRefObject.on(&apos;value&apos;, snap =&gt; preObject.innerText = JSON.stringify(snap.val(), null, 3)); // 여백 3&#125;)(); ref() 함수database의 root로 접근하게 해주고, 객체의 child키를 생성합니다. 이제 필요한 값을 저장할 수 있습니다. on() 메서드가장 강력한 메서드로서 첫 매개변수 : 이벤트 타입. 실시간 동기화를 어느 단계까지 할지를 정해줍니다.value : database의 변경이 있을 때 매번 콜백함수를 호출합니다. 두번째 매개변수 : 콜백함수snap : 콜백함수의 매개변수로서 ‘데이터 스냅샷’이라고 불립니다.데이터 스냅샷은 key name, 자식요소 반복방식 등을 return합니다.그 값을 얻고 싶으면 지금처럼 .val()함수를 호출합니다. 값이 객체라면 객체 전체를 동기화합니다.만약에 객체의 한 value가 바뀌어도, 객체 전체를 update하는데, 이를 state 동기화라고 합니다. child events데이터 동기화를 미세하게 조절할 수 있습니다. 특히 list를 다룰 때 유용합니다.어떤 요소가 add, remove, update 되었을 때 특정 child 이벤트에 동기화시키고 싶을 때 사용합니다. Firebase Overview/Database에서 object객체 프로퍼티에 JSON 객체를 넣어봅니다.12345object hobbies: &#123; &quot;coffee&quot; : &quot;coffee&quot; &#125;// 이렇게 하면 key가 coffee이고 값이 coffee인 JSON객체가 부여됩니다.// 이렇게 리스트를 추가합니다. js파일에서123456789101112131415161718192021222324252627// child_added : 리스트에 자식이 추가될 때만 작동합니다.// 처음에 모든 리스트가 동기화되며, 그 후엔 변한 부분만 동기화합니다.dbRefList.on(&apos;child_added&apos;, snap =&gt; &#123; const li = document.createElement(&apos;li&apos;); // 각 항목의 key name을 li의 id값으로 준다. li.id = snap.key; li.innerText = snap.val(); ulList.appendChild(li);&#125;);// child_changed : 자식이 바뀔때만 작동 dbRefList.on(&apos;child_changed&apos;, snap =&gt; &#123; const liChanged = document.getElementById(snap.key); liChanged.innerText = snap.val();&#125;);// child_changed : 자식이 삭제될 때만 작동 dbRefList.on(&apos;child_removed&apos;, snap =&gt; &#123; const liRemove = document.getElementById(snap.key); liRemove.remove();&#125;);","categories":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Database","slug":"Back-End/Database","permalink":"https://sharryhong.github.io/categories/Back-End/Database/"}],"tags":[{"name":"Firebase","slug":"Firebase","permalink":"https://sharryhong.github.io/tags/Firebase/"},{"name":"Realtime Database","slug":"Realtime-Database","permalink":"https://sharryhong.github.io/tags/Realtime-Database/"}],"keywords":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Database","slug":"Back-End/Database","permalink":"https://sharryhong.github.io/categories/Back-End/Database/"}]},{"title":"Algorism - 피보나치 수열 (JavaScript)","slug":"algorism13-fibonacci","date":"2017-01-24T06:16:24.000Z","updated":"2017-09-21T07:47:39.764Z","comments":true,"path":"2017/01/24/algorism13-fibonacci/","link":"","permalink":"https://sharryhong.github.io/2017/01/24/algorism13-fibonacci/","excerpt":"","text":"알고리즘 13. 피보나치 수열 (JavaScript) 피보나치 수는 F(0) = 0, F(1) = 1일 때, 2 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 점화식입니다.2 이상의 n이 입력되었을 때, fibonacci 함수를 제작하여 n번째 피보나치 수를 반환해 주세요.예를 들어 n = 3이라면 2를 반환해주면 됩니다. 피보나치 수 - 위키피디아 나의 코딩1) 피보나치가 잘 고안해 낸 식을 그대로 써서, 매개변수가 0, 1일 땐 매개변수 자체를 반환하고, 1보다 클 때는 매개변수가 0, 1이 될때까지 함수를 실행하게끔 F(n) = F(n-1) + F(n-2) 대로 해보자. 1234567891011121314function fibonacci(num) &#123; var answer = 0; if( num &lt;= 1 ) &#123; return num; &#125; else if( num &gt; 1 ) &#123; answer = fibonacci(num-1) + fibonacci(num-2); &#125; return answer;&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(fibonacci(3)); 생각과 그대로 잘 실행이 되었다. 피보나치 레오나르도 수학자님 짱 ㅋㅋㅋ","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Algorism","slug":"plus-forWeb/Algorism","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Algorism/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Algorism","slug":"Algorism","permalink":"https://sharryhong.github.io/tags/Algorism/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Algorism","slug":"plus-forWeb/Algorism","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Algorism/"}]},{"title":"예산관리 웹애플리케이션 - 01. 설계하기","slug":"portfolio-budget-app","date":"2017-01-22T13:11:58.000Z","updated":"2017-09-21T07:47:41.895Z","comments":true,"path":"2017/01/22/portfolio-budget-app/","link":"","permalink":"https://sharryhong.github.io/2017/01/22/portfolio-budget-app/","excerpt":"","text":"이번 프로젝트는 udemy 동영상 강의를 보면서 모듈패턴으로 개발해보려고 합니다.영어로 된 강의인데도 강사가 아주 뛰어난지.. 왜 알아듣기 쉬운것이죠.. 자랑이 아니고 진짜임 :)목표는 Structure, Architecture 즉, 데이터 구조 등의 설계부터 제대로 Front-End 개발을 하는 것으로, Firebase로 서버단 구현까지 해보고 싶습니다. Step 1_ 애플리케이션을 위해 기본적인 to-do list 생각하기: 수입(income), 지출(expenses)의 목록과 금액을 적고 버튼을 클릭하면 UI추가, 계산 등이 일어납니다. 01) Add event handler(버튼용) 이벤트 핸들러를 추가합니다. 02) Get input values입력창의 값을 받습니다. 03) Add the new item to our data structure데이터 구조에 새 아이템이 추가됩니다. 04) Add the new item to the UI.UI(User Interface)에도 추가됩니다. 05) Calculate budget예산을 계산합니다. 06) Update the UI.UI(User Interface)에도 추가됩니다. Step 2_ 코딩 전에 코드를 구성하는 방법에 대한 고찰 - 모듈(Modules) 모듈은 강력한 애플리케이션 설계의 핵심 요소입니다. 프로젝트의 코드 단위를 깔끔하게 분리하고 체계적으로 해줍니다. 캡슐화(encapsulate)하여 일부 데이터를 외부에서 접근하지 못하게(private)하고,다른 데이터는 외부에서 접근가능(public)하게 합니다. 이러한 개념은 프로젝트가 클수록 중요해집니다.기본적으로, 모듈은 코드를 논리적인 부분으로 나누고, 서로 상호작용(interact)하도록 해줍니다. 이 프로젝트에서는 모듈을 어떻게 나눌 것인가? UI Module Data Module 02) Get input values 04) Add the new item to the UI. 03) Add the new item to our data structure 06) Update the UI 05) Calculate budget Controller Module 01) Add event handler Step 3_ 모듈패턴(Module Patten)JavaScript의 인기있는 패턴 중 하나인 모듈패턴 방식으로 개발하고자 합니다. 관련 포스팅 : 모듈패턴(Module Patten)","categories":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Free Project","slug":"Portfolio/Free-Project","permalink":"https://sharryhong.github.io/categories/Portfolio/Free-Project/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"모듈패턴","slug":"모듈패턴","permalink":"https://sharryhong.github.io/tags/모듈패턴/"},{"name":"설계","slug":"설계","permalink":"https://sharryhong.github.io/tags/설계/"}],"keywords":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Free Project","slug":"Portfolio/Free-Project","permalink":"https://sharryhong.github.io/categories/Portfolio/Free-Project/"}]},{"title":"NHN JavaScript Convention","slug":"link-js-convention","date":"2017-01-21T05:15:52.000Z","updated":"2017-09-21T07:47:41.820Z","comments":true,"path":"2017/01/21/link-js-convention/","link":"","permalink":"https://sharryhong.github.io/2017/01/21/link-js-convention/","excerpt":"","text":"NHN ent. JavaScript 코딩 컨벤션 스터디 멤버분이 소개해주신 nhn ent. js 코딩 컨벤션. 즉 코딩 스타일 가이드입니다.이제 모듈 패턴이나 클래스를 사용하여 객체지향으로 코딩해보려고 하는데,코딩 컨벤션도 보면서 좀 더 나은 코딩을 해봐야겠습니다. :)","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Convention","slug":"Convention","permalink":"https://sharryhong.github.io/tags/Convention/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}]},{"title":"스터디그룹모임 - JavaScript 성능향상을 위한 노력, OOP(객체지향 프로그래밍)","slug":"javascript-study01","date":"2017-01-20T08:47:16.000Z","updated":"2017-09-21T07:47:41.524Z","comments":true,"path":"2017/01/20/javascript-study01/","link":"","permalink":"https://sharryhong.github.io/2017/01/20/javascript-study01/","excerpt":"","text":"스터디를 이어오고 있었는데 이제는 1주에 한번 서로 깨달은 점을 나누고,궁금한 것은 공부해와서 다음에 나누기로 하였습니다.이번주에 서로 나눈 내용은 JS성능향상을 위한 코드 리펙토링과 객체지향! 1. JavaScript 성능향상을 위한 고려조건문의 경우 if else보다는 아닐경우 빠져나오는 경우를 먼저 설정하면 성능에 좋다고 합니다.아래 예의 경우 항상 if가 참일 때는 A코드를, 아닐 경우는 B코드를 훑어봐야 합니다.12345function addList(type, num)&#123; if( dbCheck(type, num) )&#123; //...A &#125; else &#123; //...B &#125;&#125; 이를 더 좋게 코드 리펙토링 한다면1234function addList(type, num)&#123; if( !dbCheck(type, num) )&#123; return; &#125; //...B&#125; 위처럼 아닐경우 빠져나가게(return) 설정한다면 모든 코드를 훑을 필요가 없어집니다. 2. 이벤트와 함수아래처럼 이벤트가 실행될때 익명함수가 실행되게끔 하는 코드를 많이 사용하게 됩니다. 123tar.addEventListener(&quot;focusout&quot;,function(evt)&#123; // do something&#125;); 1) 이벤트와 함수를 분리하여 직관적으로 코드 리펙토링 해봅니다.여기서 addText는 콜백함수이므로 focusout시 실행되므로 ()를 적을 필요 없습니다.12345function addText(evt)&#123; // do something&#125;tar.addEventListener(&quot;focusout&quot;, addText); 2) 한번 더! 네임스페이스(전역에 하나의 객체만 추가하여 사용) 방식으로 코드 리펙토링12345678910111213var addHandler = &#123; &apos;addText&apos; = function() &#123; // do something &#125;, &apos;addNode&apos; = function() &#123; // do something &#125;, &apos;addSomething&apos; = function() &#123; // do something &#125;,&#125;tar.addEventListener(&quot;focusout&quot;, addHandler.addText); 3. OOP(Object Oriented Programming) 객체지향 프로그래밍 포스팅","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"성능향상","slug":"성능향상","permalink":"https://sharryhong.github.io/tags/성능향상/"},{"name":"callback","slug":"callback","permalink":"https://sharryhong.github.io/tags/callback/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"Algorism - 최대공약수와 최소공배수 (JavaScript)","slug":"algorism11-gcdlcm","date":"2017-01-17T06:52:00.000Z","updated":"2017-09-21T07:47:39.736Z","comments":true,"path":"2017/01/17/algorism11-gcdlcm/","link":"","permalink":"https://sharryhong.github.io/2017/01/17/algorism11-gcdlcm/","excerpt":"","text":"최대공약수, 최소공배수.. 오랜만에 다시 보았네요 ㅋㅋㅋ 알고리즘 11. 최대공약수와 최소공배수 (JavaScript) 두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환해주는 gcdlcm 함수를 완성해 보세요. 배열의 맨 앞에 최대공약수, 그 다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 gcdlcm(3,12) 가 입력되면, [3, 12]를 반환해주면 됩니다. 처음 나의 코딩1) 우선 둘 중 작은 수를 minNum, 큰 수를 maxNum로 다시 세팅한다. 2) 최소공배수 : 두 수의 공통된 배수(공배수) 중 가장 작은 수 minNum * maxNum / 최대공약수 3) 최대공약수 : 두 수의 공통된 약수(공약수) 중 가장 큰 수 두 수를 나눠봐서 나머지가 0이면 (즉 나눠지면) maxNum가 최대 공약수이고, 나머지가 생긴다면 maxNum와 나머지값을 다시 비교합니다. 123456789101112131415161718function gcdlcm(a, b) &#123; var answer = []; var minNum = Math.min(a, b); var maxNum = Math.max(a, b); answer[0] = gcd(minNum, maxNum); answer[1] = lcm(minNum, maxNum); return answer;&#125;// 최대공약수function gcd(minNum, maxNum)&#123; return (minNum % maxNum) === 0 ? maxNum : gcd(maxNum, minNum % maxNum);&#125;// 최소공배수function lcm(minNum, maxNum)&#123; return minNum * maxNum / gcd(minNum, maxNum);&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(gcdlcm(3,12));","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Algorism","slug":"plus-forWeb/Algorism","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Algorism/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Algorism","slug":"Algorism","permalink":"https://sharryhong.github.io/tags/Algorism/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Algorism","slug":"plus-forWeb/Algorism","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Algorism/"}]},{"title":"JavaScript - Module Patton","slug":"javascript-module-patton","date":"2017-01-16T08:09:04.000Z","updated":"2017-09-21T07:47:41.273Z","comments":true,"path":"2017/01/16/javascript-module-patton/","link":"","permalink":"https://sharryhong.github.io/2017/01/16/javascript-module-patton/","excerpt":"","text":"이번에 진행할 Free Project에서 Module Patton으로 Module을 구현하려고 합니다. Module : 모듈은 application’s architecture(구조)의 필수 요소이며 일반적으로 프로젝트의 코드 단위를 명확하게 분리하고 구성하는 데 도움이됩니다. 자바스크립트에서는 모듈 구현을 위한 몇가지 방법이 있습니다.The Module pattern (모듈패턴)Object literal notation (객체 리터럴 표기법)AMD modulesCommonJS modulesECMAScript Harmony modules Module Patton(모듈 패텬)모듈 패턴은 전통적인 소프트웨어 엔지니어링에서 클래스를 위한 private 및 public로 나뉜 캡슐화를 제공하는 방법입니다. 12345678910111213141516171819202122232425262728293031323334// data를 다루는 모듈var budgetController = (function()&#123; // private 영역 // 클로저 내부에 있고 publicTest 메소드를 통해서만 엑세스가 가능하기 때문입니다. var x = 20; // private 프로퍼티 var add = function(a)&#123; // private 메소드 return x + a; &#125; // public 영역 : 필요한 것만 공개합니다. return &#123; // 항상 x와 add에 엑세스하므로 클로저(closure)가 생성됩니다. publicTest: function(b)&#123; return add(b); &#125; &#125;&#125;)();// UI를 다루는 모듈var UIController = (function()&#123; // code&#125;)();// data와 UI를 같이 다루는 모듈var controller = (function(budgetCtrl, UICtrl)&#123; var z = budgetCtrl.publicTest(5); return&#123; anotherPublic: function()&#123; console.log(z); &#125; &#125;&#125;)(budgetController, UIController); 위 코드에서 public으로 공개된 코드를 사용하여 controller.anotherPublic(); 이런식으로 budgetController의 publicTest 메소드에 접근합니다. controller 내에서 budgetCtrl.publicTest(5);로 하지 않고, budgetController.publicTest(5);로도 접근이 가능하지만, 이 경우 나중에 budgetController의 이름을 바꾸게 된다면 모든 코드를 수정해야합니다.따라서, 위처럼 매개변수로 받은 이름을 쓴다면 쉽게 수정이 가능해집니다. IIFE (Immediately Invoked Function Expressions 즉시실행함수)123(function()&#123; // code&#125;)(); 위처럼 뒤에 ()를 붙이면 함수가 즉시 실행됩니다.함수내부 프로퍼티, 메소드는 외부에서 접근을 못한다는 개념을 사용하여 전역을 오염시키지 않도록 하는 방법입니다. 참고 자료Udemy - The Complete JavaScript CourseNonblock 블로그Learning JavaScript Design Patterns","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"IIFE","slug":"IIFE","permalink":"https://sharryhong.github.io/tags/IIFE/"},{"name":"Module Patton","slug":"Module-Patton","permalink":"https://sharryhong.github.io/tags/Module-Patton/"},{"name":"Closure","slug":"Closure","permalink":"https://sharryhong.github.io/tags/Closure/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"Algorism - 평균구하기 (JavaScript)","slug":"algorism-02","date":"2017-01-13T07:21:28.000Z","updated":"2017-09-21T07:47:39.690Z","comments":true,"path":"2017/01/13/algorism-02/","link":"","permalink":"https://sharryhong.github.io/2017/01/13/algorism-02/","excerpt":"","text":"알고리즘 02. 평균구하기 (JavaScript) def average(list):함수를 완성해서 매개변수 list의 평균값을 return하도록 만들어 보세요.어떠한 크기의 list가 와도 평균값을 구할 수 있어야 합니다. 처음 나의 코딩1) 목표 : 배열 값을 모두 더하여 length만큼 나눠 평균을 구하자. 2) 매개변수로 들어온 배열.length의 경우 2번이상 쓰이므로 변수에 저장하자. 123456789101112function average(array)&#123; var result = 0; var arrLength = array.length; for(var i = 0; i &lt; arrLength; i++)&#123; result += array[i]; &#125; return result/arrLength;&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.var testArray = [5,3,4]console.log(&quot;평균값 : &quot; + average(testArray)); 다른분의 코딩을 참고한 코드 리펙토링ES6문법으로 코드 리펙토링해보았습니다.우선 let 선언으로 정의된 블록내에서만 존재하는 지역변수로 설정하고,for of문을 사용하여 각 배열 값이 자동으로 더해지게 하였습니다.주의사항 : for of문의 경우 브라우저 호환이 안되는 경우가 많습니다. 1234567891011function average(array)&#123; let result = 0; for(let item of array)&#123; result += item; &#125; return result/array.length;&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.var testArray = [5,3,4]console.log(&quot;평균값 : &quot; + average(testArray)); for of문for…of 문(statement)은 반복가능한 객체 (Array, Map, Set, String, TypedArray, arguments 객체 등을 포함)에 대해서 반복하고 각 개별 속성값에 대해 실행되는 문이 있는 사용자 정의 반복 후크를 호출하는 루프를 생성합니다.","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Algorism","slug":"plus-forWeb/Algorism","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Algorism/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Algorism","slug":"Algorism","permalink":"https://sharryhong.github.io/tags/Algorism/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Algorism","slug":"plus-forWeb/Algorism","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Algorism/"}]},{"title":"Algorism - 핸드폰번호 가리기 (JavaScript)","slug":"algorism-01","date":"2017-01-12T16:35:55.000Z","updated":"2017-09-21T07:47:39.641Z","comments":true,"path":"2017/01/13/algorism-01/","link":"","permalink":"https://sharryhong.github.io/2017/01/13/algorism-01/","excerpt":"","text":"한국에도 이런 사이트가 있어 기쁩니다. ^^해외에는 codecademy, udacity, udemy.. 등의 우수한 강의사이트가 있는데 tryhelloworld도 못지않게 훌륭하네요!JavaScript에 해당하는 알고리즘을 풀고난 후, 다른사람들의 풀이를 보니 공부에 많은 도움이 되고 있습니다. :) 알고리즘 01. 핸드폰번호 가리기 (JavaScript) 별이는 헬로월드텔레콤에서 고지서를 보내는 일을 하고 있습니다. 개인정보 보호를 위해 고객들의 전화번호는 맨 뒷자리 4자리를 제외한 나머지를 “*“으로 바꿔야 합니다.전화번호를 문자열 s로 입력받는 hide_numbers함수를 완성해 별이를 도와주세요예를들어 s가 “01033334444”면 “*******4444”를 리턴하고, “027778888”인 경우는 “*****8888”을 리턴하면 됩니다. 처음 나의 코딩1) 목표 : 문자열 중 마지막 4개만 제외하고 별표로 바꿔야한다. : 문자열 length만큼 for문을 돌면서 별표로 바꾸자. (length - 4까지) 2) 내가 아는 내장 메소드 중 문자열을 배열값으로 분리하여 저장하는 split()로 하나하나 값을 지정할 수 있게 한다. 3) for문을 돌며 각 배열 값을 별표로 바꾸자. 4) join() 메소드로 배열의 모든 요소를 연결하여 문자열로 만들어보자. 12345678910function hide_numbers(s)&#123; var result = &quot;&quot;; result = s.split(&quot;&quot;); for(var i = 0; i &lt; result.length - 4; i++)&#123; result[i] = &quot;*&quot;; &#125; return result.join(&quot;&quot;);&#125;console.log(&quot;결과 : &quot; + hide_numbers(&apos;01033334444&apos;)); 다른분의 코딩을 참고한 코드 리펙토링배열로 바꾸지 않고 바로 별표를 대입시킨 코드if문을 삼항식으로 적용하여 한줄로 간단하게 적용한 코드 12345678910function hide_numbers(s)&#123; var result = &quot;&quot;; var sLength = s.length; for(var i = 0; i &lt; sLength; i++)&#123; result += i &lt; sLength - 4 ? &quot;*&quot; : s.charAt(i); &#125; return result;&#125;console.log(&quot;결과 : &quot; + hide_numbers(&apos;01033334444&apos;)); charAt()이라는 메소드를 공부해보았습니다.str.charAt(index) 문자열에서 index 문자를 반환합니다.if문을 삼항식으로 써보았습니다. 문자열의 길이 s.length - 4 보다 작다면, 즉, 마지막 4개 이전의 index 값에는 *를 대입하고, 나머지는 원래의 s.charAt(i)값을 대입합니다.","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Algorism","slug":"plus-forWeb/Algorism","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Algorism/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Algorism","slug":"Algorism","permalink":"https://sharryhong.github.io/tags/Algorism/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Algorism","slug":"plus-forWeb/Algorism","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Algorism/"}]},{"title":"Photo Gallery - AJAX, JSON data","slug":"project-gallery","date":"2017-01-10T06:33:31.000Z","updated":"2017-09-21T07:47:42.071Z","comments":true,"path":"2017/01/10/project-gallery/","link":"","permalink":"https://sharryhong.github.io/2017/01/10/project-gallery/","excerpt":"","text":"사진 갤러리 : JavaScript, AJAX, JSON, CSS3결과화면 보기해당 소스 보기 Window10의 기본 사진 애플리케이션 기능을 웹버전으로 만들어보는 작은 프로젝트입니다. :) 특징 및 기능1) AJAX로 JSON data 불러오기2) JSON photo개수에 맞는 template 동적 생성3) hover, focus시 CSS3 transform, transition 사용4) 사진 click시 중앙에 확대, 확대시 검정배경 높이만큼 나오기5) 슬라이드 쇼 버튼 클릭시 슬라이드 쇼 재생, 다시 클릭시 멈추는 기능6) 슬라이드 쇼 재생시 사진을 클릭하면 재생이 끝나는 기능 주요 코드1) AJAX로 JSON data 불러오기12345678var xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;, &quot;./data/gallery.json&quot;);xhr.send();xhr.onreadystatechange = function() &#123; if(this.status === 200 &amp;&amp; this.readyState === 4) &#123; var data = JSON.parse(this.response); var template = &apos;&apos;; var photos = data.results; gallery.json 파일 내부의 results 배열객체 값을 변수 photos에 저장합니다. 2) JSON의 photos 개수만큼 template 동적 생성index.html &lt;ul class=&quot;ajax-result&quot;&gt;&lt;/ul&gt; 내부에1234567891011for(var i=0; i&lt;photos.length; i++)&#123; template += [ &apos;&lt;li&gt;&apos;, &apos;&lt;a href=&quot;javascript:;&quot; class=&quot;photo-link&quot;&gt;&apos;, &apos;&lt;img class=&quot;photo-img&quot; src=&quot;&apos;+photos[i].image+&apos;&quot; alt=&quot;&apos;+photos[i].alt+&apos;&quot;&gt;&apos;, &apos;&lt;/a&gt;&apos;, &apos;&lt;/li&gt;&apos; ].join(&apos;&apos;);&#125;result_view.innerHTML = template; 처음에 저장했던 photos 변수에 담긴 JSON data의 갯수만큼 template을 생성하여 뿌려줍니다. 3) CSS3 transform, transition, animation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// transition을 주어 애니메이션 효과를 냅니다..photo-link&#123; position: static; display: inline-block; overflow: hidden; transition: .3s all ease-in-out;&#125;.photo-img&#123; display: inline-block; vertical-align: middle; transition: .5s all ease-in-out; /* vendorless fallback */ -o-transition: .5s all ease-in-out; /* opera */ -ms-transition: .5s all ease-in-out; /* IE 10 */ -moz-transition: .5s all ease-in-out; /* Firefox */ -webkit-transition: .5s all ease-in-out; /*safari and chrome */&#125;// 사진 hover, focus시 약간 확대됩니다..photo-link:hover .photo-img,.photo-link:focus .photo-img &#123; transform: scale(1.1);&#125;// 사진 클릭시 JavaScript에서 class=&quot;on&quot;이 추가되어 아래 style이 적용됩니다..photo-link.on&#123; position: absolute; z-index: 90; top: 0; left: 0; width: 100%; height: inherit; animation: ani-opacity 1s;&#125;.photo-link.on .photo-img&#123; width: 100%; height: 100%;&#125;// CSS Animation@keyframes ani-opacity &#123; 0% &#123; opacity: 0; &#125; 100% &#123; opacity: 1; &#125;&#125;// 클릭된 사진을 제외한 사진은 안보이게 하는 class=&quot;off&quot; style입니다..photo-link.off&#123; display:none;&#125; 4) 사진 click시 중앙에 확대, 확대시 검정배경 높이만큼 나오기검정배경에 관한 코드123456789101112131415161718192021// 검정배경 Div요소 만들기var photoGallery = document.querySelector(&apos;.photo-gallery&apos;).firstElementChild;var menuCoverDiv = document.createElement(&apos;div&apos;);menuCoverDiv.setAttribute(&apos;class&apos;, &apos;menu-cover&apos;);// 검정 배경 나오게 하기function menuCover(el) &#123; // 목표노드.부모노드.insertBefore(insert삽입할노드, target목표노드) photoGallery.parentNode.insertBefore(menuCoverDiv, photoGallery); // 확대된 사진의 height var photoHeight = el.offsetHeight; // 사진크기와 브라우저크기를 비교하여 검정 배경 height 정하기 if((windowHeight-90) &gt; photoHeight)&#123; menuCoverDiv.style.height = (windowHeight-10)+&apos;px&apos;; &#125;else&#123; menuCoverDiv.style.height = (photoHeight+30)+&apos;px&apos;; &#125;&#125;// 검정 배경 없애기function removeMenuCover() &#123; photoGallery.parentNode.removeChild(menuCoverDiv);&#125; 사진 클릭시 확대되는 코드123456789101112131415161718192021222324252627282930// 각 사진 클릭시 photoShow 함수 실행function photoAddEvent() &#123; for(var i=0; i&lt;photoLink.length; i++)&#123; photoLink[i].addEventListener(&quot;click&quot;, photoShow, false); &#125;&#125;// 사진 클릭시 커지는 함수function photoShow() &#123; console.log(&quot;photoShow함수실행&quot;); // 현재 사진 index = photoLink.indexOf(this); // 현재 사진 제외하고 안보이게 처리 for(var j=0; j&lt;photoLink.length; j++)&#123; if( j !== index ) &#123; photoLink[j].classList.toggle(&quot;off&quot;); &#125; &#125; // 현재 사진 확대 this.classList.toggle(&quot;on&quot;); if(!photoClick)&#123; menuCover(this); photoClick = !photoClick; console.log(&apos;사진 클릭&apos;); &#125;else&#123; removeMenuCover(); photoClick = !photoClick; index = 0; console.log(&apos;사진 클릭해제&apos;); &#125;&#125; 5) 슬라이드 쇼 버튼 클릭시 슬라이드 쇼 재생, 다시 클릭시 멈추는 기능6) 슬라이드 쇼 재생시 사진을 클릭하면 재생이 끝나는 기능1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 슬라이드 쇼를 멈추고 사진들이 원래대로 돌아오게 하는 함수function stopSlideShow(e)&#123; console.log(&quot;stopSlideShow함수실행&quot;); // 슬라이드 버튼이 눌러졌다면 if(chkBtn || PauseBtnOn)&#123; photoLink[index].classList.remove(&quot;on&quot;); &#125;else&#123; photoLink[index-1].classList.remove(&quot;on&quot;); &#125; index = 0; clearInterval(slideInterval); photoAddEvent(); removeMenuCover(); slideBtn.classList.remove(&quot;pause-interval&quot;); slideBtn.classList.remove(&quot;on&quot;); for(var j=0; j&lt;photoLink.length; j++)&#123; photoLink[j].classList.remove(&quot;off&quot;); &#125; chkBtn = false; PauseBtnOn = false; photoClick = false; removeStopSlideShow();&#125;// stopSlideShow함수 removeEventfunction removeStopSlideShow()&#123; for(var j=0; j&lt;photoLink.length; j++)&#123; photoLink[j].removeEventListener(&quot;click&quot;, stopSlideShow, false); &#125;&#125;// 슬라이드 쇼 함수function slideShow() &#123; for(var j=0; j&lt;photoLink.length; j++)&#123; // 슬라이드 쇼 함수 진행 중 확대된 사진을 클릭하면 슬라이드 쇼 멈추기 photoLink[j].addEventListener(&quot;click&quot;, stopSlideShow, false); if( j !== index ) &#123; photoLink[j].classList.add(&quot;off&quot;); &#125; &#125; photoLink[index].classList.add(&quot;on&quot;); menuCover(photoLink[index]); global.slideInterval = setInterval(function()&#123; index++; if(index &lt; photoLink.length)&#123; photoLink[index-1].classList.remove(&quot;on&quot;); photoLink[index-1].classList.add(&quot;off&quot;); photoLink[index].classList.remove(&quot;off&quot;); photoLink[index].classList.add(&quot;on&quot;); menuCover(photoLink[index]); console.log(index); &#125;else &#123; // 슬라이드 쇼 끝난 후 chkBtn = false; PauseBtnOn = false; photoClick = false; stopSlideShow(); &#125; &#125;, 2000);&#125;// 슬라이드 버튼 클릭시slideBtn.onclick = function()&#123; // 슬라이드 재생 if(!chkBtn)&#123; slideShow(); photoRemoveEvent(); slideBtn.classList.remove(&quot;pause-interval&quot;); slideBtn.classList.add(&quot;on&quot;); chkBtn = true; &#125;else&#123; // 슬라이드 멈춤 clearInterval(global.slideInterval); slideBtn.classList.remove(&quot;on&quot;); slideBtn.classList.add(&quot;pause-interval&quot;); chkBtn = false; PauseBtnOn = true; &#125;&#125;","categories":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Free Project","slug":"Portfolio/Free-Project","permalink":"https://sharryhong.github.io/categories/Portfolio/Free-Project/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"https://sharryhong.github.io/tags/AJAX/"},{"name":"JSON","slug":"JSON","permalink":"https://sharryhong.github.io/tags/JSON/"},{"name":"Gallery","slug":"Gallery","permalink":"https://sharryhong.github.io/tags/Gallery/"}],"keywords":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Free Project","slug":"Portfolio/Free-Project","permalink":"https://sharryhong.github.io/categories/Portfolio/Free-Project/"}]},{"title":"JavaScript String 프로퍼티, 메소드","slug":"javascript-string","date":"2017-01-09T04:58:17.000Z","updated":"2017-09-21T07:47:41.481Z","comments":true,"path":"2017/01/09/javascript-string/","link":"","permalink":"https://sharryhong.github.io/2017/01/09/javascript-string/","excerpt":"","text":"Free Project를 진행하면서 자주 사용하는 프로퍼티, 메소드 등을 계속 추가할 예정입니다. :) 목차charAt 메소드replace 메소드repeat 메소드slice 메소드substring 메소드 charAt 메소드문자열에서 특정 위치의 문자를 구할 수 있습니다. 1str.charAt(index) index : 문자열의 위치 인덱스 값으로 0부터 시작리턴값 : index 위치의 문자 알고리즘 코드에 올린 내용입니다.마지막 번호 4개를 제외하고 *로 보이게 하기 (핸드폰번호 가리기)12345678910function hide_numbers(s)&#123; var result = &quot;&quot;; var sLength = s.length; for(var i = 0; i &lt; sLength; i++)&#123; result += i &lt; sLength - 4 ? &quot;*&quot; : s.charAt(i); &#125; return result;&#125;console.log(&quot;결과 : &quot; + hide_numbers(&apos;01033334444&apos;)); 문자열의 길이 s.length - 4 보다 작다면, 즉, 마지막 4개 이전의 index 값에는 *를 대입하고, 나머지는 원래의 s.charAt(i)값을 대입합니다. (목차로 돌아가기) replace 메소드어떤 패턴에 일치하는 일부 또는 모든 부분이 교체된 새로운 문자열을 반환합니다. String.prototype.replace() 문법1str.replace(regexp|substr, newSubStr|function) regexp : 정규표현식, substr : 문자열newSubStr : 새로운 문자열, function : 함수 예) 속성 class 값 중 ‘no-js’ 값을 ‘js’로 변경하기12var html_class_attr = element.getAttribute(&apos;class&apos;);element.setAttribute(&apos;class&apos;, html_class_attr.replace(/no-js/,&apos;js&apos;)); (목차로 돌아가기) repeat 메소드1str.repeat(count) count : 0이상의 정수. 기존의 문자열을 반복할 횟수리턴값 : 횟수만큼 복사를 포함하는 새 문자열 1&quot;abc&quot;.repeat(2); // 결과 : // &quot;abcabc&quot; 브라우저 호환 : IE, 오페라 지원안함ES6에서 추가된 메소드입니다. (목차로 돌아가기) slice 메소드지정한 문자열 시작위치 ~ 끝위치까지의 문자열을 반환합니다. 1str.slice(beginSlice[, endSlice]) (목차로 돌아가기) substring 메소드1str.substring(indexStart[, indexEnd])","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"String","slug":"String","permalink":"https://sharryhong.github.io/tags/String/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"Web DOM API - Element","slug":"javascript-webAPI-Element","date":"2017-01-07T06:10:20.000Z","updated":"2017-09-21T07:47:41.638Z","comments":true,"path":"2017/01/07/javascript-webAPI-Element/","link":"","permalink":"https://sharryhong.github.io/2017/01/07/javascript-webAPI-Element/","excerpt":"","text":"Free Project를 진행하면서 자주 사용하는 Element Web API를 계속 추가할 예정입니다. :) element.classList요소의 class속성 목록을 반환합니다. 브라우저 호환 : IE10이상add : 요소의 클래스 목록에 클래스 추가remove : 요소의 클래스 목록에서 클래스 삭제toggle : 요소의 클래스 목록에서 특정 클래스 전환contains : 요소의 클래스 목록이 특정 클래스를 포함 여부 확인 classList를 지원하는지 확인하고 class속성에서 no-js값을 js로 변경하는 코드123456789101112131415161718(function(global)&#123; &apos;use strict&apos;; // &lt;html&gt; 요소를 찾아서 class 속성에서 &apos;no-js&apos; 값을 &apos;js&apos;로 변경 global.html = query(&apos;html&apos;); if ( html.classList ) &#123; // 신형 방식 IE 10+ html.classList.remove(&apos;no-js&apos;); html.classList.add(&apos;js&apos;); &#125; else &#123; // 구형 방식 var html_class_attr = html.getAttribute(&apos;class&apos;); // 설정 html.setAttribute(&apos;class&apos;, html_class_attr.replace(/no-js/,&apos;js&apos;)); &#125;&#125;(this)); 관련 My 포스팅JavaScript DOM 참고 자료Web APIs Element - MDN","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"DOM API","slug":"Front-End/DOM-API","permalink":"https://sharryhong.github.io/categories/Front-End/DOM-API/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"https://sharryhong.github.io/tags/DOM/"},{"name":"Web API - Element","slug":"Web-API-Element","permalink":"https://sharryhong.github.io/tags/Web-API-Element/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"DOM API","slug":"Front-End/DOM-API","permalink":"https://sharryhong.github.io/categories/Front-End/DOM-API/"}]},{"title":"JavaScript Array 프로퍼티, 메소드","slug":"javascript-array","date":"2017-01-07T05:22:51.000Z","updated":"2017-09-21T07:47:40.192Z","comments":true,"path":"2017/01/07/javascript-array/","link":"","permalink":"https://sharryhong.github.io/2017/01/07/javascript-array/","excerpt":"","text":"Free Project를 진행하면서 자주 사용하는 프로퍼티, 메소드 등을 계속 추가할 예정입니다. :) 목차length 프로퍼티indexOf 메소드splice 메소드 length 프로퍼티배열의 원소 개수를 나타냅니다. 만약에 배열 index에 임의대로 값을 저장하면 length는 가장 큰 index를 기준으로 정해집니다.123456var arr = []; // 변수 배열로 초기화console.log(arr.length); // 0arr = [2,1,2]; // arr.length = 3arr[100] = 5;console.log(arr.length); // 101 예) DOM 요소 개수만큼 class name 추가하기해당 Free Project 바로가기 1234567891011121314151617181920// class=&quot;photo-link&quot;인 요소들을 모두 선택합니다.// 이 때 변수 photoLink에 요소들이 유사배열로 저장됩니다.var photoLink = document.querySelectorAll(&apos;.photo-link&apos;);for(var i=0; i&lt;photoLink.length; i++)&#123; photoLink[i].onclick = function() &#123; // 클릭한 요소가 몇번째 index에 있는가 var idx = photoLink.indexOf(this); for(var j=0; j&lt;photoLink.length; j++)&#123; // 클릭한 요소가 아닌 모든 요소 선택 if( j !== idx ) &#123; photoLink[j].classList.toggle(&quot;off&quot;); &#125; &#125; // 클릭한 요소에 class name 토글(add, remove) this.classList.toggle(&quot;on&quot;); &#125;&#125; (목차로 돌아가기) indexOf 메소드배열에서 지정된 요소를 찾을 수있는 첫 번째 인덱스를 반환하고 존재하지 않으면 -1을 반환합니다. 예) 배열 중 지정한 값 삭제하는 함수 만들기1234567891011121314151617var originArray = [0,1,2,3,4,5];function removeValue(originArray, idx) &#123; // 매개변수 idx값이 몇번째 index인지 알아냅니다. var idx_check = originArray.indexOf(idx); // 만약 -1이라면 배열에 없는 값이므로 false반환하고 끝냅니다. if ( idx_check === -1 ) &#123; return false; &#125; // 만약 -1보다 크다면 배열에 있는 값입니다. if ( idx_check &gt; -1 ) &#123; // splice메소드를 사용하여 해당 index로부터 1개를 삭제합니다. return originArray.splice(idx_check, 1); &#125;&#125;removeValue(originArray, 3); // 결과 originArray = [0,1,2,4,5] (목차로 돌아가기) splice 메소드배열의 내용을 추가/제거하는 데 사용됩니다. 1array.splice(start, deleteCount[, item1[, item2[, ...]]]) start : 변경이 시작되는 인덱스deleteCount : 배열에서 제거를 할 요소의 수itemN : 배열에 추가될 요소 (목차로 돌아가기) 참고 자료Array - MDN인사이드 자바스크립트 - 한빛미디어 연관 포스팅JavaScript Array - forEach, map, filter 내장 메소드","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Array","slug":"Array","permalink":"https://sharryhong.github.io/tags/Array/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"CSS3 Hover Effect Transition, Transform, Animation","slug":"link-css3","date":"2017-01-06T12:31:55.000Z","updated":"2017-09-21T07:47:41.665Z","comments":true,"path":"2017/01/06/link-css3/","link":"","permalink":"https://sharryhong.github.io/2017/01/06/link-css3/","excerpt":"","text":"CSS3 효과 모음 사이트 CSS3 Transition, Transform, Animation 효과를 직관적으로 보여주는 사이트입니다.재미있고 쉽게 익힐 수 있습니다. ^^","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"https://sharryhong.github.io/tags/CSS3/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}]},{"title":"Movie 박스오피스 - AJAX, Movie API","slug":"project-ajax-movieapi","date":"2016-12-30T16:12:57.000Z","updated":"2017-09-21T07:47:42.017Z","comments":true,"path":"2016/12/31/project-ajax-movieapi/","link":"","permalink":"https://sharryhong.github.io/2016/12/31/project-ajax-movieapi/","excerpt":"","text":"결과화면 보기 박스오피스 사이트 : AJAX 통신, Movie API 사용 2017-01-04 코드 리펙토링 : 익스플로러(IE)에서는 for of문이 인식되지 않아 일반 for문으로 처리하였습니다. 하단에 설명 추가 특징 및 기능1) 영화진흥위원회가 제공하는 영화 API사용: 로컬 서버에서는 구현이 잘 되고 있으나 github의 gh-pages에서는 API data가 불러와 지지 않습니다. 그래서 2016-12-19일 기준으로 JSON파일을 만들어 연결하였습니다. 2) AJAX 비동기 통신 사용 3) template 동적 생성 4) 랭킹 1~3위는 빨강배경, 4~10위는 회색배경 적용 5) 순위 변경 data가 0 일땐 녹색 - 표시, 순위 상승시 빨강 화살표, 순위 하락시 data 중 마이너스 삭제하고 파랑 화살표 표시 추가 예정 : 영화 상세 페이지디자인 : CGV사이트 참고영화 포스터 : API에서 제공하지 않아 못 넣었습니다. 아쉽네요 ㅜㅜ 코드 설명1) AJAX관련 코드 : 자세한 설명은 여기에서 123var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;, &quot;http://www.kobis.or.kr/kobisopenapi/webservice/rest/boxoffice/searchDailyBoxOfficeList.json?key=발급받은키&amp;targetDt=&quot;+ today);xhr.send(); 제공하는 영화 API URL 맨 뒤에는 알고싶은 날짜를 적으면 됩니다. 저는 Date() 클래스를 사용하여 하루 전 날짜를 넣어주었습니다. (당일 날짜는 안되더군요.) 2) 하루 전 날짜 구하기 1234567var d = new Date();var yy = d.getFullYear();var mm = d.getMonth() + 1;var dd = d.getDate() - 1;// var today = yy + &quot;&quot; + &quot;&quot; + mm + &quot;&quot; + dd;// 혹은var today = `$&#123;yy&#125;$&#123;mm&#125;$&#123;dd&#125;`; Date() 클래스의 인스턴스 dd.getMonth() 리턴값은 0(1월) ~ 11(12월) 3) 랭킹 1~3위는 빨강배경, 4~10위는 회색배경 적용 123456var rank_array = document.querySelectorAll(&apos;.rank&apos;);var gray_array = Array.prototype.slice.apply(rank_array);var gray_rank = gray_array.slice(3);for(var i=0; i&lt;gray_rank.length; i++)&#123; gray_rank[i].classList.add(&apos;gray&apos;);&#125; &lt;strong class=&quot;rank&quot;&gt;&#39;+&#39;No.&#39;+movie.rank+&#39;&lt;/strong&gt;&#39; 전체를 유사배열로 받아옵니다.이 것을 Array.prototype.slice.apply(rank_array);로 실제 배열처럼 사용할 수 있게 합니다..slice(3)은 네번째 배열값부터 끝까지 적용한다는 뜻입니다.즉, 이 코드는 class=&quot;rank&quot;를 가진 전체 요소 중에 네번째 배열값부터 끝까지 class=”gray”를 추가시킨다. 는 것인데 css상에는 아래처럼 되어있어 자동으로 회색배경이 적용됩니다.123.movie-contents .rank.gray&#123; background: #555;&#125; 전체 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586(function(global, XHR)&#123; &apos;use strict&apos;; var createXHR = (function() &#123; XHR = XHR || ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); return function() &#123; return new XHR; &#125;; &#125;)(); var xhr = createXHR(); var result_view = document.querySelector(&apos;.ajax-result&apos;); //오늘 날짜 var d = new Date(); var yy = d.getFullYear(); var mm = d.getMonth() + 1; var dd = d.getDate() - 1; var today = `$&#123;yy&#125;$&#123;mm&#125;$&#123;dd&#125;`; xhr.open(&apos;GET&apos;, &quot;http://www.kobis.or.kr/kobisopenapi/webservice/rest/boxoffice/searchDailyBoxOfficeList.json?key=발급받은키&amp;targetDt=&quot;+ today); xhr.send(); xhr.onreadystatechange = function() &#123; if ( this.status === 200 &amp;&amp; this.readyState === 4 ) &#123; console.log(&apos;통신 데이터 전송 성공! ^^&apos;); // console.log(this.response); // text file var getmovies = this.response; var template = &apos;&apos;; // text -&gt; object getmovies = JSON.parse(getmovies); // json파일내에 있는 속성 results var movies = getmovies.boxOfficeResult.dailyBoxOfficeList; // movies 반복 순환 처리 for(var movie of movies) &#123; template += [ &apos;&lt;li class=&quot;movie-contents&quot;&gt;&apos;, &apos;&lt;strong class=&quot;rank&quot;&gt;&apos;+&apos;No.&apos;+movie.rank+&apos;&lt;/strong&gt;&apos;, &apos;&lt;h3 class=&quot;name&quot;&gt;&apos;+movie.movieNm+&apos;&lt;/h3&gt;&apos;, &apos;&lt;p class=&quot;opendt small&quot;&gt;&apos;+&apos;개봉일 : &apos;+&apos;&lt;span&gt;&apos;+movie.openDt+&apos;&lt;/span&gt;&apos;+&apos;&lt;/p&gt;&apos;, &apos;&lt;p class=&quot;audiacc small&quot;&gt;&apos;+&apos;누적 관객 수 : &apos;+&apos;&lt;span&gt;&apos;+movie.audiAcc+&apos;&lt;/span&gt;&apos;+&apos;명&apos;+&apos;&lt;/p&gt;&apos;, &apos;&lt;p class=&quot;rankinten small&quot;&gt;&apos;+&apos;순위 변화 : &apos;+&apos;&lt;span class=&quot;rank-change&quot;&gt;&apos;+movie.rankInten+&apos;&lt;/span&gt;&apos;+&apos;&lt;/p&gt;&apos;, &apos;&lt;/li&gt;&apos; ].join(&apos;&apos;); &#125; &#125; else &#123; console.log(&apos;통신 데이터 전송 실패&apos;); &#125; result_view.innerHTML = template; // 랭킹 4위부터 회색배경 var rank_array = document.querySelectorAll(&apos;.rank&apos;); var gray_array = Array.prototype.slice.apply(rank_array); var gray_rank = gray_array.slice(3); for(var i=0; i&lt;gray_rank.length; i++)&#123; gray_rank[i].classList.add(&apos;gray&apos;); &#125; // 순위변경 표시하기 var rankinten_array = document.querySelectorAll(&apos;.rank-change&apos;); for(var a=0; a&lt;rankinten_array.length; a++)&#123; var rankinten_el = rankinten_array[a]; var rankinten_el_first = rankinten_el.firstChild; // console.log(rankinten_el_first.nodeValue); // 순위변경이 없다면 숫자 0을 없애고 css에 적용한 zero클래스 붙이기 if(rankinten_el_first.nodeValue == 0)&#123; rankinten_el_first.nodeValue = &apos;&apos;; rankinten_el.classList.add(&apos;zero&apos;); &#125; // 순위가 올랐다면 css에 적용한 up클래스 붙이기 else if(rankinten_el_first.nodeValue &gt; 0)&#123; rankinten_el.classList.add(&apos;up&apos;); &#125; // 순위가 내려갔다면 css에 적용한 down클래스 붙이기, 마이너스 없애기 else if(rankinten_el_first.nodeValue &lt; 0)&#123; // console.log(rankinten_el_first.nodeValue[0]); var el_value = rankinten_el_first.nodeValue; var result = el_value.slice(1)+el_value.slice(2, el_value.length); // console.log(result); rankinten_el_first.nodeValue = result; rankinten_el.classList.add(&apos;down&apos;); &#125; &#125; &#125;&#125;)(this, this.XMLHttpRequest); IE에서 작동되지 않는 문제점 발견크롬에서 작업하고 크로스브라우징을 위해 모바일과 IE, 엣지에서 확인해보니 IE에서는 실행이 되지 않았습니다.여러가지 분석 결과 for of문이 인식되지 않는 것을 알았고, json data 객체를 불러들이기 위해 for of문 대신 일반 for문을 사용하였습니다. 코드 리펙토링 부분1234567891011for(var i=0; i&lt;movies.length; i++) &#123; template += [ &apos;&lt;li class=&quot;movie-contents&quot;&gt;&apos;, &apos;&lt;strong class=&quot;rank&quot;&gt;&apos;+&apos;No.&apos;+movies[i].rank+&apos;&lt;/strong&gt;&apos;, &apos;&lt;h3 class=&quot;name&quot;&gt;&apos;+movies[i].movieNm+&apos;&lt;/h3&gt;&apos;, &apos;&lt;p class=&quot;opendt small&quot;&gt;&apos;+&apos;개봉일 : &apos;+&apos;&lt;span&gt;&apos;+movies[i].openDt+&apos;&lt;/span&gt;&apos;+&apos;&lt;/p&gt;&apos;, &apos;&lt;p class=&quot;audiacc small&quot;&gt;&apos;+&apos;누적 관객 수 : &apos;+&apos;&lt;span&gt;&apos;+movies[i].audiAcc+&apos;&lt;/span&gt;&apos;+&apos;명&apos;+&apos;&lt;/p&gt;&apos;, &apos;&lt;p class=&quot;rankinten small&quot;&gt;&apos;+&apos;순위 변화 : &apos;+&apos;&lt;span class=&quot;rank-change&quot;&gt;&apos;+movies[i].rankInten+&apos;&lt;/span&gt;&apos;+&apos;&lt;/p&gt;&apos;, &apos;&lt;/li&gt;&apos; ].join(&apos;&apos;);&#125; 연관 링크영화진흥위원회 API","categories":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Free Project","slug":"Portfolio/Free-Project","permalink":"https://sharryhong.github.io/categories/Portfolio/Free-Project/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"https://sharryhong.github.io/tags/AJAX/"},{"name":"JSON","slug":"JSON","permalink":"https://sharryhong.github.io/tags/JSON/"},{"name":"영화 API","slug":"영화-API","permalink":"https://sharryhong.github.io/tags/영화-API/"}],"keywords":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Free Project","slug":"Portfolio/Free-Project","permalink":"https://sharryhong.github.io/categories/Portfolio/Free-Project/"}]},{"title":"Networking - AJAX 비동기 통신 기술","slug":"javascript-ajax","date":"2016-12-29T09:31:02.000Z","updated":"2017-09-21T07:47:40.137Z","comments":true,"path":"2016/12/29/javascript-ajax/","link":"","permalink":"https://sharryhong.github.io/2016/12/29/javascript-ajax/","excerpt":"","text":"AJAX(Asynchronous Javascript And XML) 개념Javascript가 XML을 만나면서 비동기 통신을 한다. -&gt; 요새는 XML보다는 JSON으로 하지만 이름은 그대로 사용하고 있다고 하네요. ^^XML은 자유롭게 마음대로 정할 수 있지만 무겁고 구조화가 어렵다는 단점이 있습니다. 이를 해결하기위해 JSON 등장! 비동기 통신 : view가 update하는 동안에도(data 변경 등) 사용자는 다른 일을 할 수 있습니다. 자바스크립트 객체가 특정 데이터(업데이트 등을 할 데이터)를 서버에 주고받고 하여 그 부분만 업데이트합니다.필요한 부분만 별도로 요청, 응답받아 처리합니다. 모든데이터를 업데이트할 필요없어 불필요한 대역폭 감소가 가능하고 비용절감을 가져옵니다. 장점 : 사용자에게 더 나은 사용 경험 제공. 속도, 비용 절감단점 : 접근성에는 열악합니다. -&gt; 해결하기 위해 등장 : WAI-ARIA AJAX 기술브라우저에서 페이지를 이동하지 않고 자바스크립트를 통해 HTTP Request를 보내고 받아 JS에서 처리할 수 있습니다. 서버 설치 : $ npm install http-server -g로컬 서버 연결 : $ http-server -o -a localhost -p 8081: http://localhost:8081로 자동으로 띄워줍니다. 1) create. XHR(XML Http Request)AJAX 통신을 하기 위한 생성자를 통해 객체를 만듭니다. 여러개를 만들어 동시다발적으로 수행시킬 수 있습니다.1var xhr = new XMLHttpRequest(); 2) open 메소드 : setting 구간. 요청의 방식과 url설정1xhr.open(&apos;GET&apos;, &apos;data/data.json&apos;); 3) send 메소드 : 요청 전송. 통신 시작1xhr.send(); 응답확인 : xhr.response 콘솔창에 쳐보면 data.json 데이터를 볼 수 있습니다. XMLHttpRequest에서 http요청을 보냈을 때 발생하는 이벤트의 종류readyState 속성AJAX 요청에 따라 0~4까지 변화0 : open 메소드 호출 전1 : open 메소드 호출 후2 : 보낸 요청에 대해 응답 헤더가 수신된 후3 : 응답의 바디 부분이 수신중일 때4 : 모든 응답이 수신되었을 때 status 속성HTTP response의 응답 헤더에 기록된 코드200 : OK. 정상적으로 data를 보냄404 : Not Found500 : Internal Error onreadystatechange 속성readyState가 변할 때마다 호출되는 콜백 함수 123456789var xhr = new XMLHttpRequest();xhr.onreadystatechange = function a() &#123; console.log(this.readyState, this.status); if(this.readyState == 4 &amp;&amp; this.status == 200) &#123; console.log(this.response); &#125;&#125;xhr.open(&apos;GET&apos;, &apos;./data.txt&apos;);xhr.send(); JSON (JavaScript Object Notation)AJAX 형태로 받은 문자를 객체로, 객체를 문자로 바꿀 수 있는 능력을 가지고 있습니다.자바스크립트 객체를 문자열로 표현하므로 프로그램간에 전달하기 편리합니다.서버에서 보낼 데이터를 JSON형태로 브라우저로 전송데이터를 수신한 브라우저는 자바스크립트를 통해 데이터를 파싱하고 문서에 반영합니다. JSON APIJSON.stringify(object) 메소드 : 인자로 받은 객체를 JSON 문자열로 반환JSON.parse(string) 메소드 : 인자로 받은 문자열을 Javascript Object로 변경하여 반환※ undefined, function 은 변환되지 않습니다. 참고 자료helloworld - 자바스크립트와 웹 프론트엔드My Github 링크","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"AJAX","slug":"Front-End/AJAX","permalink":"https://sharryhong.github.io/categories/Front-End/AJAX/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"AJAX","slug":"AJAX","permalink":"https://sharryhong.github.io/tags/AJAX/"},{"name":"JSON","slug":"JSON","permalink":"https://sharryhong.github.io/tags/JSON/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"AJAX","slug":"Front-End/AJAX","permalink":"https://sharryhong.github.io/categories/Front-End/AJAX/"}]},{"title":"DOM(Document Object Model)","slug":"javascript-dom","date":"2016-12-28T13:18:11.000Z","updated":"2017-09-21T07:47:40.542Z","comments":true,"path":"2016/12/28/javascript-dom/","link":"","permalink":"https://sharryhong.github.io/2016/12/28/javascript-dom/","excerpt":"","text":"JavaScript를 배운다는 건…core(문법), core library(기본 제공 함수 등), BOM, DOM이 중 DOM에 대해 정리해보겠습니다. DOM(Document Object Model)노드, 스타일, 속성, 이벤트, 위치 및 크기 등을 다룰 수 있는 다양한 기능이 포함되어 있습니다.※ 노드 : HTML 웹페이지 구성요소의 가장 작은 단위로써 요소, 주석, 텍스트 등이 모두 노드에 해당합니다. DOM과 HTML페이지의 관계 HTML페이지 로딩-&gt; 2. 파싱(Parsing)을 거쳐 작성된 마크업 요소와 1:1로 매칭되는 DOM객체 생성(DOM Tree)예를들어, 파싱단계에서 &lt;div&gt;를 만나면 HTMLDivElement라는 클래스의 인스턴스(객체)를 생성하게 됩니다.-&gt; 3. 브라우저 화면에 출력 핵심 DOM 객체Node : 노드를 다루는 기본 기능과 프로퍼티 제공. 노드를 탐색, 조작※ 노드에는 Element node(요소), Text node(텍스트, 빈칸포함), 주석 노드 등도 모두 포함Document : text node, element node, attribute node 생성Element : 요소의 기본 기능과 프로퍼티 제공. 속성과 이벤트 제어Text : 텍스트를 다루는 기능Attribute : 속성을 다루는 기능HTMLDocument : Document객체를 확장하여 HTML용 프로퍼티와 메서드를 추가한 객체HTMLElement : HTML요소의 기본 기능과 프로퍼티 제공. id, className, style등이 존재 DOM객체 Node 상속구조 Node 기능 노드 탐색, 조작하는 프로퍼티와 메서드 주요 프로퍼티 node.parentNode 부모노드 탐색node.childNodes 자식노드들 탐색node.firstChild 첫번째 자식노드 탐색node.lastChild 마지막 자식노드 탐색node.previousSibling 이전 형제노드 탐색node.nextSibling다음 형제노드 탐색node.children 그 안의 요소만 가져옴. 빈칸은 textnode인데 가져오지 않으므로 편리하다. node.nodeName요소의 이름을 대문자로 반환node.nodeType 요소노드는 1, 텍스트노드 3, 주석노드 8node.nodeValue 텍스트노드에만 접근 가능. 텍스트 노드의 실제 값 반환. 요소노드의 경우는 null 반환node.hasChildNodes() 자식이 있으면 true, 없으면 false※ 아래는 IE8이하는 안되나 요소만 찾아줌 node.parentElement 부모요소 탐색 node.firstElementChild 첫 자식요소 노드 탐색 node.lastElementChild 마지막 자식 요소 노드 탐색 node.previousElementSibling 이전 형제요소 탐색 node.nextElementSibling 다음 형제요소 탐색 주요 메서드 node.hasChildNodes() true/false 반환node.hasChildNodes() true/false 반환node.cloneNode(boolean) false가 기본값. true면 자식까지 복제부모노드.appendChild(자식노드) 부모의 꽁지쪽에 붙이기목표노드.부모노드.insertBefore(insert삽입할노드, target목표노드) node.removeChild(childnode)target_node.parentNode.replaceChild(replace_node, target_node) 노드 교체. 위치를 교체하는 것이 아니라, 이전 노드를 삭제 한다.이전 노드를 삭제하지만 결과 값으로 반환된다. 사용 예 var el = document.getElementById(&#39;div-01&#39;).nextSibling; DOM객체 Document 상속구조 Node &gt; Document 기능 Text node, Element node 생성 주요 프로퍼티 주요 메서드 document.createElement(&#39;element&#39;) 요소 만들기. 실제 DOM에 붙는건 아님 document.createTextNode(&#39;text&#39;) 텍스트 노드 만들기 document.createAttribute(&quot;name&quot;); 잘쓰지않음document.getElementById(&quot;idname&quot;); id로 대상(요소노드)을 선택 document.getElementsByTagName(&quot;p&quot;); 요소명으로 선택document.getElementsByClassName(&#39;classname&#39;); 클래스명으로 선택document.querySelector(css selector);막강!!! IE8이상. 첫번째 하나만 반환document.querySelectorAll(css selector); 상동. 전체 복수로 반환createEvent()target.addEventListener(type, listener[, options]);dispatchEvent()removeListener() DOM객체 HTMLDocument 상속구조 Node &gt; Document &gt; HTMLDocument 기능 HTML문서 전용 프로퍼티, 메서드 주요 프로퍼티 주요 메서드 close()open()write()Element[]getElementByName() DOM객체 Element 상속구조 Node &gt; Element 기능 속성을 다루는 기능, 이벤트 주요 프로퍼티 tagName 요소의 이름반환. 예전방식 주요 메서드 Element[]ElementsByTagName()element.hasAttribute(attName); true/false 반환element.getAttribute(attributeName);element.removeAttribute(attrName);element.setAttribute(name, value);target.addEventListener(type, listener[, options]);dispatchEvent()removeListener() 사용 예 var parent_el = document.getElementById(&#39;parent&#39;); console.log(&#39;data-con:&#39;, parent_el.getAttribute(&#39;data-con&#39;)); DOM객체 HTMLElement 상속구조 Node &gt; Element &gt; HTMLElement 기능 HTML요소 전용 프로퍼티, 메서드 주요 프로퍼티 element.idelement.classNameelement.innerHTML = content;노드 동적생성을 쉽게해줌element.style.color = &quot;blue&quot;;element.offsetWidth border까지의 widthelement.offsetHeight border까지의 heightelement.offsetLeftelement.offsetTop 주요 메서드 onkeydownonkeypressonkeyuponclickondbclickonmousedownonmousemoveonmouseoutonmouseoveronmouseup 사용 예 var parent_el = document.getElementById(&#39;parent&#39;);console.log(&#39;id:&#39;, parent_el.id);console.log(&#39;class:&#39;, parent_el.className);console.log(&#39;title:&#39;, parent_el.title); 참고 자료DOM - MDNMy Github 링크웹 프론트엔드 개발자를 위한, 자바스크립트+jQuery 완전정복 스터디 - 김춘경(딴동네)","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"DOM API","slug":"Front-End/DOM-API","permalink":"https://sharryhong.github.io/categories/Front-End/DOM-API/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"https://sharryhong.github.io/tags/DOM/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"DOM API","slug":"Front-End/DOM-API","permalink":"https://sharryhong.github.io/categories/Front-End/DOM-API/"}]},{"title":"BOM(Brower Object Model)","slug":"javascript-bom","date":"2016-12-28T09:06:59.000Z","updated":"2017-09-21T07:47:40.353Z","comments":true,"path":"2016/12/28/javascript-bom/","link":"","permalink":"https://sharryhong.github.io/2016/12/28/javascript-bom/","excerpt":"","text":"JavaScript를 배운다는 건…core(문법), core library(기본 제공 함수 등), BOM, DOM이 중 BOM에 대해 정리해보겠습니다. BOM(Brower Object Model)웹 브라우저를 구성하는 객체들이 포함되어 있습니다. Window 객체Javascript 실행시 가장 상위에 존재하는 객체입니다.웹 페이지의 정보에 접근하거나 변경을 할 수 있습니다.윈도우 창을 구성하며 server-side에는 없습니다.브라우저별로 문법이 다르기 때문에 크로스브라우징이 어렵습니다.IE9부터는 표준을 지켜서 괜찮으나 IE8은 고려해야 합니다. Navigator : 브라우저 정보Location : 주소창 부분History : 이번보기 다음보기 등Document : 웹 페이지 문서의 HTML, CSS 등에 대한 접근 가능. 가장 중요한 개념Screen : 디스플레이 부분 ※크롬 콘솔창에 window라고 치면 window 객체에 내장되어 있는 프로퍼티들이 쭉 나옵니다.※ wondow.은 생략이 가능합니다. 주요 프로퍼티 등window.devicePixelRatio : 기기의 픽셀 농도window.innerWidth : window의 화면 가로 폭window.innerHeight : window의 화면 세로 폭window.alert(&quot;Dialog 창 띄우기&quot;); : 오늘날은 alert창 별로 쓰지 않고 console로 씁니다.window.prompt(&#39;당신의 이름은?&#39;, &#39;예) 홍길동&#39;); : 입력창이 뜹니다. 잘 쓰지 않습니다.window.confirm(&quot;당신은 청년입니까?&quot;); : Yes, No 값을 받을 수 있습니다.window.open(&#39;http://www.naver.com&#39;); : 들어가자마자 새창이 뜹니다. 요샌 쓰지 않습니다.window.scrollX = window.pageXOffset; : 가로 스크롤바 위치window.scrollY =window.pageYOffset : 세로 스크롤바 위치 (나중에 스크롤 moving사용시 씀)크롬은 둘다 사용. 브라우저별로 다른 문법 사용window.scrollTo(0,1000); : x축 0, y축 1000px 절대적 위치이동window.scrollBy(0,100); : x축 0, y축 1000px 상대적 위치이동window.setInterval(할일(함수), 시간(밀리초)); : 주기마다 계속 함수 반복window.setTimeout(할일(함수), 시간(밀리초)); : 시간 후에 1회만 함수 실행window.clearInterval() : 멈춤. 변수에 setInterval되는 것을 담아놨다가 ()안에 넣기window.requestAnimationFrame(); : setInterval의 단점을 보완. IE10부터. Location (주소창) 객체location.href; : 주소 “http://caniuse.com“location.protocol; : “http:”location.domain;location.host; : “caniuse.com”location.hostname; : “caniuse.com”location.port;location.hash; : 해당페이지의 목적지(id) History 객체history.back() : 한칸 뒤로가기history.forward() : 한칸 앞페이지 가기history.go(-2) : 2칸 뒤로가기 등 제어가능 Screen 객체정확하게 말하자면 내 노트북의 모니터 screen 정보를 말하는 것입니다.통계할 때 빼곤 잘 쓰지 않습니다.screen.width : 스크린 widthscreen.height : 스크린 heightscreen.availHeight : 실제 사용가능한 heightscreen.orientation : 중요! 모바일 등 제어12// 기울기, 가로모드, onchange되면.. 설정가능ScreenOrientation &#123;angle: 0, type: &quot;landscape-primary&quot;, onchange: null&#125;` 예 )12345screen.orientation.onchange = fnction() &#123; if ( screen.orientation.type == &apos;landscape-primary&apos;) &#123; ... &#125;&#125; Navigator 객체navigator.userAgent : 사용자의 브라우저 식발자를 감지하여 거기에 맞는 디자인이 가능합니다.: 크롬 개발자도구의 모바일 버전으로 테스트가 가능합니다.“Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36”navigator.appCodeName : “Mozilla”navigator.userAgent.indexOf(&#39;Chrome&#39;) &gt; -1; : Chrome이라는게 있니? 즉, 크롬이니?. 해당 문구가 없다면 -1이 나옵니다. -1보다 크다면(크롬이라면) true를 반환합니다.navigator.vendor : 크롬 웹브라우저의 경우 “Google Inc.”navigator.cookieEnabled : 쿠키를 쓸 수 있나? true. 현재 모든 브라우저는 쿠키 쓸 수 있습니다.!!window.localStorage : 새로운 기술. 로컬스토리지navigator.onLine : 온라인인가? true : 온라인일 때 다운받게 하기 등 가능navigator.language : 주 언어 “ko” Document 객체웹 페이지 문서의 HTML, CSS 등에 대한 접근을 가능하게 하므로 Front-End개발에서 가장 중요한 개념입니다. document.title : titledocument.doctype : &lt;!DOCTYPE html&gt;document.compatMode : “CSS1Compat” 표준모드. “BackcCompat” 비표준모드돔스크립트(DOM Script) : 자바스크립트를 사용한 문서 동적 제어1234567891011// 웹 표준 호환 모드라면 standard_mode에 true값이 참조(Reference)됩니다.var standard_mode = document.compatMode == &apos;CSS1Compat&apos;;// 문서에서 root element인 &lt;html&gt; 요소를 찾아서 변수 html에 참조됩니다.var html = document.documentElement;// 웹 표준 호환 모드라면 첫번째 코드 블록문이 실행if ( standard_mode ) &#123; // 변수 html에 참조된 문서 객체 &lt;html&gt;요소에 class 속성 값을 &apos;standard&apos;로 설정합니다. html.setAttribute(&apos;class&apos;, &apos;standard&apos;);&#125; else &#123; html.setAttribute(&apos;class&apos;, &apos;nostandard&apos;);&#125; document.activeElement; : focus된, 활성화된 엘리먼트를 알 수 있습니다. 접근성에서 중요합니다.document.write(&#39;&#39;); : html코드에 추가되는데 이젠 이렇게 잘 쓰지 않습니다. DOM에 대한 포스팅 바로가기","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"DOM API","slug":"Front-End/DOM-API","permalink":"https://sharryhong.github.io/categories/Front-End/DOM-API/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"https://sharryhong.github.io/tags/BOM/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"DOM API","slug":"Front-End/DOM-API","permalink":"https://sharryhong.github.io/categories/Front-End/DOM-API/"}]},{"title":"JavaScript ES6 문법 - Arrow functions","slug":"javascript-es6-arrow-functions","date":"2016-12-26T04:52:09.000Z","updated":"2017-09-21T07:47:40.691Z","comments":true,"path":"2016/12/26/javascript-es6-arrow-functions/","link":"","permalink":"https://sharryhong.github.io/2016/12/26/javascript-es6-arrow-functions/","excerpt":"","text":"Arrow functions(애로우 펑션, 화살표 함수 표현식)화살표 함수 표현식(arrow function expression)은 함수 표현식(function expression)에 비해 구문이 짧으며(예제 1.)this, arguments, super 또는 new.target을 자체 바인딩하지 않습니다(예제 2.). 메소드가 아닌 함수에 가장 적합하며 생성자로 사용할 수 없습니다(예제 3.) 장점 : 브라우저 입장에서 함수를 받아들일 때 엔진으로 알아야 할 정보가 줄어들어, 성능이 좋아집니다. 문법123456(매개변수) =&gt; &#123; statements &#125; // 매개변수가 하나일 땐 괄호 생략 가능() =&gt; &#123; statements &#125; // 매개변수가 없는 함수는 괄호가 필요합니다._ =&gt; &#123; statements &#125; // _를 쓰는 경우 위처럼 매개변수가 없다는 의미로 사용됩니다.// 객체 리터럴을 return하는 경우는 body를 괄호속에 넣어야 합니다.매개변수 =&gt; (&#123; foo: bar &#125;) 12345// 한줄일 경우 &#123;&#125;, return을 생략가능합니다.var func = x =&gt; x * x;// &#123;&#125; 를 쓴다면 return도 써야합니다.var func = (x, y) =&gt; &#123; return x + y; &#125;; 예제 1. 짧은 문법 제공12345678910111213141516var materials = [ &quot;Hydrogen&quot;, &quot;Helium&quot;, &quot;Lithium&quot;, &quot;Beryllium&quot;];var materialsLength1 = materials.map(function(material)&#123; return material.length&#125;);var materialsLength2 = materials.map((material)=&gt;&#123; return material.length&#125;);var materialsLength3 = materials.map(material=&gt; material.length); 위 materialsLength1, materialsLength2, materialsLength3의 결과는 모두 [8, 6, 7, 9]로 같습니다. 예제 2.화살표함수의 this : 자기보다 상위 스코프의 this를 씁니다. 기존 JavaScript 문법의 this123456789101112function Person() &#123; // Person () 생성자는`this`를 자신의 인스턴스로 정의합니다. this.age = 0; setInterval(function growUp() &#123; // non-strict mode에서는 growUp()함수는 `this`를 정의합니다. // Person () 생성자에 의해 정의된 `this`와는 다른 전역(window) 객체로 정의됩니다. this.age++; &#125;, 1000);&#125;var p = new Person(); // age가 증가하지 않습니다. 위와 같은 문제를 해결하기 위해서 ECMAScript 3/5 문법에서는 아래와 같이 this를 변수에 저장하였습니다.1234567891011function Person() &#123; var that = this; that.age = 0; setInterval(function growUp() &#123; // callback은 `that`변수를 참조합니다. that.age++; &#125;, 1000);&#125;var p = new Person(); // age가 증가합니다. 혹은 bind를 사용하여 아래와같이 해결하기도 합니다.123456789function Person() &#123; this.age = 0; setInterval(function growUp() &#123; this.age++; &#125;.bind(this), 1000);&#125;var p = new Person(); // age가 증가합니다. Arrow functions은 this를 자체 바인딩하지 않으므로 아래처럼 사용하면 예상대로 작동됩니다.123456789function Person()&#123; this.age = 0; setInterval(() =&gt; &#123; this.age++; // `this`는 Person객체를 제대로 참조합니다. &#125;, 1000);&#125;var p = new Person(); // age가 증가합니다. 예제 3. (2017.02.27 추가) 위 이미지는 크롬에서 함수표현식과 화살표함수의 차이를 보기 위한 코드입니다.function a(x, y)에는 prototype: Object가 있고 b(x,y)에는 없습니다.즉, 함수표현식은 프로토타입이 있기 때문에 생성자 함수가 될 수 있지만, 화살표 함수는 생성자 함수가 될 수 없습니다. 연관 링크Arrow functions - MDN ES6 포스팅변수선언 let, constBlocks and IIFEsStrings 문자열표기법 등Arrow functionsClassrest parameterspread operatordefault parameter","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sharryhong.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"arrow functions","slug":"arrow-functions","permalink":"https://sharryhong.github.io/tags/arrow-functions/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"JavaScript ES6 문법 - 변수선언 let, const","slug":"javascript-es6","date":"2016-12-24T16:54:47.000Z","updated":"2017-09-21T07:47:41.042Z","comments":true,"path":"2016/12/25/javascript-es6/","link":"","permalink":"https://sharryhong.github.io/2016/12/25/javascript-es6/","excerpt":"","text":"ES6 변수, 상수 선언 키워드let : 정의된 블록내에서만 존재하는 변수 선언 (지역 변수)const : 위와 동일, 상수(변하지 않는 값) 선언 var : ES6문법 이전부터 사용하던 변수 선언 (전역 변수) 1234var x = &apos;global&apos;; // 전역 변수let y = &apos;global&apos;; // 지역 변수console.log(this.x); // &quot;global&quot;console.log(this.y); // undefined Scoping rules - var와 let 비교12345678function varTest() &#123; var x = 1; if (true) &#123; var x = 2; // 위의 x와 같은 변수 console.log(x); // 결과 : 2 &#125; console.log(x); // 결과 : 2&#125; 12345678function letTest() &#123; let x = 1; if (true) &#123; let x = 2; // 위의 x와 다른 변수 console.log(x); // 결과 : 2 &#125; console.log(x); // 결과 : 1&#125; 내부함수 코드를 명확하게 해주는 let1234567891011var list = document.getElementById(&quot;list&quot;);for (let i = 1; i &lt;= 5; i++) &#123; // for문 내에서만 사용할 변수이므로 let 사용 let item = document.createElement(&quot;li&quot;); item.appendChild(document.createTextNode(&quot;Item &quot; + i)); item.onclick = function (ev) &#123; console.log(&quot;Item &quot; + i + &quot; is clicked.&quot;); &#125;; list.appendChild(item);&#125; 변수 선언 &amp; 호이스팅 (2017-02-18 수정)var : scope내 최상단으로 호이스팅됩니다. ※ 호이스팅 : 어떤 위치에 있든지 위로 끌어올려지는 현상12345(function()&#123; console.log(a); // var a 까지만 호이스팅되어 undefined var a = 10; // 값 할당 console.log(a); // 10&#125;)(); let과 const : TDZ (temporal dead zone, 임시사각지대) 블락 스코프 내에서는 지역변수/상수에 대한 호이스팅이 이뤄지기는 하나, 선언된 위치 이전까지는 해당 변수/상수를 인식하지 못합니다. 출처 : 고무곰님 블로그123456789101112function do_something() &#123; console.log(foo); // ReferenceError let foo = 2;&#125;&#123; let a = 2; &#123; console.log(a); // 2일 것 같지만 이것도 error이다. let a = 3; &#125;&#125; 전역변수 (2017-02-19 추가)1234567891011var a = 1;window.a; // 1delete window.a; // falselet b = 2;window.b; // undefinedwindow.c = 3;c; // 3delete window.c; // truec; // error c is not defined var a = 1; 처럼 var로 변수를 선언하면 전역 변수가 되어 window 객체의 프로퍼티로 됩니다.하지만 delete window.a 로 삭제를 하려고 해도 삭제를 할 수가 없습니다. let은 전역변수가 아니므로 window 객체에 담기지 않습니다.전역변수로 만들고 싶으면 window.c = 3;처럼 직접 window객체의 프로퍼티로 만듭니다.이 때에는 delete window.c;로 지울 수 있습니다. 연관 링크let - MDNJavaScript Reference - MDNECMAScript 6 Tutorial ES6 포스팅변수선언 let, constBlocks and IIFEsStrings 문자열표기법 등Arrow functionsClassrest parameterspread operatordefault parameter","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sharryhong.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"let","slug":"let","permalink":"https://sharryhong.github.io/tags/let/"},{"name":"const","slug":"const","permalink":"https://sharryhong.github.io/tags/const/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"AngularJS 도입 선택 가이드 - Naver","slug":"angularjs-story","date":"2016-12-23T07:28:48.000Z","updated":"2017-09-21T07:47:39.859Z","comments":true,"path":"2016/12/23/angularjs-story/","link":"","permalink":"https://sharryhong.github.io/2016/12/23/angularjs-story/","excerpt":"","text":"AngularJS 도입 선택 가이드 - Naver D2 예전에 관리했던 블로그를 살펴보는데 참 재밋네요 :)그 당시에도 앵귤러에 관심이 있어서 링크해두었던 글입니다.","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"https://sharryhong.github.io/tags/AngularJS/"},{"name":"도입","slug":"도입","permalink":"https://sharryhong.github.io/tags/도입/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}]},{"title":"javascript30.com 재미있는 자바스크립트 강의","slug":"link-javascript-30","date":"2016-12-23T05:15:52.000Z","updated":"2017-09-21T07:56:49.252Z","comments":true,"path":"2016/12/23/link-javascript-30/","link":"","permalink":"https://sharryhong.github.io/2016/12/23/link-javascript-30/","excerpt":"","text":"javascript30.com | github 소스 영어로 진행하는데도 재미있게 알아들을 수 있는 신선한 라이브코딩식 강의! 처음엔 30 Day Vanilla JS Coding Challenge라고 되어있기에 문제를 하나씩 던져주고 해결하라고 하는건가? 라고 생각했는데, 동영상으로 라이브코딩처럼 진행하는 방식입니다. Vanilla JS, 즉, 라이브러리 등을 사용하지 않고 순수 자바스크립트로 코딩하는 데, console.log를 하나하나 찍어가면서 테스트해보기 때문에 더 정감이 가네요 ㅋㅋ 저는 아직 자바스크립트 ES6 문법을 제대로 익히지 못했는데, 이 강의는 ES6를 쓰는군요!재미있게 강의 보면서 자연스럽게 찾아보고 익혀야겠습니다. :)","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}],"tags":[{"name":"javascript30.com","slug":"javascript30-com","permalink":"https://sharryhong.github.io/tags/javascript30-com/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}]},{"title":"NVM(Node Version Manager)으로 node.js 버전관리하기","slug":"nodejs-nvm","date":"2016-12-20T13:27:35.000Z","updated":"2017-09-27T07:00:34.678Z","comments":true,"path":"2016/12/20/nodejs-nvm/","link":"","permalink":"https://sharryhong.github.io/2016/12/20/nodejs-nvm/","excerpt":"","text":"Node Version Manager webpack이 자꾸 안되었던 이유가 node.js의 버전때문이었습니다. 하아 ㅜㅜ 지금이라도 알았으니 다행.. ^^gulp + webpack 설정으로 사용하고 싶어, 스터디 팀끼리 서로 정보 공유하며 씨름하다 결국엔 성공했습니다. ^^ 씐나씐나 ~~~ Windows 환경에서 NVM을 설치하여 node.js 버전을 바꾸며 사용하는 방법입니다.(언제나 그렇듯 Mac은 쉽죠잉 : 맥은 여기 참조) 1) 기존에 사용하던 node를 삭제합니다. 윈도우의 경우 제어판의 프로그램 제거에서 삭제하면 됩니다. 2) nvm을 설치합니다. nvm-setup.zip 다운받아 설치 3) 터미널에서 $ nvm install v4.4.6 처럼 사용할 버전의 노드를 설치합니다. 4) $ nvm ls 로 설치된 버전을 확인 할 수 있습니다. 1234$ nvm ls * 6.9.2 (Currently using 64-bit executable) 4.4.6 위처럼 저는 기존에 사용하던 gulp를 위해 v4.x와 현재 사용할 webpack + gulp를 위해 v6.x를 설치하였습니다. 5) 노드 버전을 바꾸어봅니다. $ nvm use 4.4.6node버전 확인 : $ node -v 만약 node가 설치 안된 것 처럼 나올 때는 터미널을 껐다 켜봅니다. 6) gulp를 전역에 설치합니다. $ npm install --global gulp주의할 점은 gulp가 버전별로 설치가 되어야 한다는 점입니다.즉, $ nvm use 4.4.6 에서도 설치, $ nvm use 6.9.2로 바꿔서도 설치해줍니다. 7) 이제 프로젝트에 해당하는 node 버전으로 바꾼 후에 기존처럼 사용하면 됩니다.","categories":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Nodejs","slug":"Back-End/Nodejs","permalink":"https://sharryhong.github.io/categories/Back-End/Nodejs/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://sharryhong.github.io/tags/node-js/"},{"name":"NVM","slug":"NVM","permalink":"https://sharryhong.github.io/tags/NVM/"}],"keywords":[{"name":"Back-End","slug":"Back-End","permalink":"https://sharryhong.github.io/categories/Back-End/"},{"name":"Nodejs","slug":"Back-End/Nodejs","permalink":"https://sharryhong.github.io/categories/Back-End/Nodejs/"}]},{"title":"SASS Nesting(중첩)","slug":"sass-nesting","date":"2016-12-19T07:14:28.000Z","updated":"2017-09-21T07:47:42.129Z","comments":true,"path":"2016/12/19/sass-nesting/","link":"","permalink":"https://sharryhong.github.io/2016/12/19/sass-nesting/","excerpt":"","text":"해당 코드가 있는 Github 바로가기01해당 코드가 있는 Github 바로가기02 Nesting(중첩)중첩은 반복을 제거하고 스타일링에 분명한 DOM관계를 보여줌으로서 코드를 효율적으로 만듭니다. 확장자가 SCSS, SASS 일 때 문법이 다른데,SCSS파일의 경우는 기존의 CSS의 문법과 동일합니다.123456.parent &#123; color: blue; .child &#123; font-size: 12px; &#125;&#125; SASS파일의 경우 {}를 쓰지 않고 들여쓰기로 구분합니다. ;도 쓰지 않습니다.1234.parent color: blue .child font-size: 12px 위의 SCSS와 SASS의 CSS 컴파일 결과는 같습니다.1234567.parent &#123; color: blue;&#125;.parent .child &#123; font-size: 12px;&#125; 속성에 관련한 Nesting :1234567.parent &#123; font : &#123; family: Roboto, sans-serif; size: 12px; decoration: none; &#125;&#125; 컴파일 결과12345.parent &#123; font-family: Roboto, sans-serif; font-size: 12px; font-decoration: none;&#125; &amp; : 부모 참조 선택자. 중첩된 구조에서 사용합니다.123.button &amp;:hover background: skyblue 컴파일 결과123.button:hover &#123; background: skyblue;&#125; @extend : 선택자 상속. 그룹핑 개념으로 선언된 다른 규칙의 내용을 상속받습니다.123456789101112131415161718$btn-radius: 4px$btn-align: center$btn-gap: .6em$btn-bg: #fe9977.button display: inline-block padding: $btn-gap $btn-gap background: $btn-bg text-align: $btn-align &amp;:hover background: skyblue.button-error @extend .button color: #fff border: 3px solid green 컴파일 결과1234567891011.button, .button-error &#123; display: inline-block; padding: 0.6em 0.6em; background: #fe9977; text-align: center; &#125; .button:hover, .button-error:hover &#123; background: skyblue; &#125;.button-error &#123; color: #fff; border: 3px solid green; &#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"CSS/SASS","slug":"Front-End/CSS-SASS","permalink":"https://sharryhong.github.io/categories/Front-End/CSS-SASS/"}],"tags":[{"name":"SASS","slug":"SASS","permalink":"https://sharryhong.github.io/tags/SASS/"},{"name":"Nesting","slug":"Nesting","permalink":"https://sharryhong.github.io/tags/Nesting/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"CSS/SASS","slug":"Front-End/CSS-SASS","permalink":"https://sharryhong.github.io/categories/Front-End/CSS-SASS/"}]},{"title":"SASS Variables (변수)","slug":"sass-variable","date":"2016-12-19T06:27:48.000Z","updated":"2017-09-21T07:47:42.178Z","comments":true,"path":"2016/12/19/sass-variable/","link":"","permalink":"https://sharryhong.github.io/2016/12/19/sass-variable/","excerpt":"","text":"해당 코드가 있는 Github 바로가기01해당 코드가 있는 Github 바로가기02 CSS로 style 코드를 작성하다보면 반복사용 하는 것들을 한번에 관리하면 좋겠다는 생각을 하게 됩니다.이럴 때 사용하면 좋을 문법이 sass의 변수입니다. 나중엔 mixin, 함수 개념등을 알면 좋은데 우선 변수만 잘 써도 일이 확 줄어드는 것을 알 수 있습니다. 조으다! ^^ Variables (변수)변수는 가독성과 유지보수를 향상시켜줍니다. 문법 : $를 붙여 변수를 만들고 값을 대입합니다.12345// 변수 선언$translucent-white: rgba(255,255,255,0.3);// 변수 사용시background-color: $translucent-white; 변수이름 작성 규칙변수 이름 사이에 공백을 사용하지 않습니다.변수 이름의 음절 사이에 _ , - 등을 사용합니다. _ , - 구별을 하지 않습니다.만약 프로그래밍에 익숙해서 camelCase방식이 익숙하다면 사용이 가능하지만 camelCase방식은 함수 이름에 사용되므로 권장하지는 않습니다. !global : 전역변수처럼 사용가능하게 합니다.12345678#main &#123; $width: 5em !global; width: $width;&#125;#sidebar &#123; width: $width;&#125; !default : 기본값. null값을 제외하곤 다른 값이 우선시됩니다.123$set-width: 900px;$set-width: 1000px !default// 의 경우 900px로 됩니다. Data Type (데이터 유형) 데이터유형 설명 예 null 빈 값 number 숫자 1.2, 3, 14px (특이하게 단위가 붙어도 숫자형입니다.) string 문자 color (#, rgba, …) “../img/icon.jpg”, ‘Time, serif’, #333 boolean 논리. true, false list 배열 개념 1.5em Helvetica bold; or Helvetica, Arial, sans-serif; map 객체 개념 (key1: value1, key2: value2);","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"CSS/SASS","slug":"Front-End/CSS-SASS","permalink":"https://sharryhong.github.io/categories/Front-End/CSS-SASS/"}],"tags":[{"name":"SASS","slug":"SASS","permalink":"https://sharryhong.github.io/tags/SASS/"},{"name":"Variables","slug":"Variables","permalink":"https://sharryhong.github.io/tags/Variables/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"CSS/SASS","slug":"Front-End/CSS-SASS","permalink":"https://sharryhong.github.io/categories/Front-End/CSS-SASS/"}]},{"title":"Link-AngularJS","slug":"Link-AngularJS","date":"2016-12-18T09:57:31.000Z","updated":"2017-09-21T07:47:39.537Z","comments":true,"path":"2016/12/18/Link-AngularJS/","link":"","permalink":"https://sharryhong.github.io/2016/12/18/Link-AngularJS/","excerpt":"","text":"앵귤러 개발자가 놓치기 쉬운 10가지 사실들 - 김정환님 블로그 포스팅을 보며 앵귤러 코드 리펙토링하고 있습니다.저 글 뿐 아니라 앵귤러 세미나내용도 있으니 우리 썬쓰 SunS(스터디 팀)끼리 열심히 해볼 생각입니다. ^^저도 차근차근 실력쌓아서 도움되는 블로그를 만들고 싶네요. :)","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"https://sharryhong.github.io/tags/AngularJS/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}]},{"title":"2016 정보접근성 기술 컨퍼런스 & WAI-ARIA","slug":"web-aria","date":"2016-12-13T04:31:01.000Z","updated":"2017-09-21T07:47:42.198Z","comments":true,"path":"2016/12/13/web-aria/","link":"","permalink":"https://sharryhong.github.io/2016/12/13/web-aria/","excerpt":"","text":"12월 9일 금요일. UN 인권의 날 기념 - 2016 정보접근성 기술 컨퍼런스에 다녀왔습니다.집에서 먼 거리에 있어 상암쪽은 살면서 두번째네요~결론은.. 눈 비비며 먼 길 다녀온 보람이 있었다는 것입니다. ^^ 특히 우리 프론트엔드 개발스쿨의 야무쌤 파트였던 WAI-ARIA부분은 예전부터 알고 싶던 기술이었기 때문에 더 귀를 쫑끗하며 들었습니다.한국 웹접근성 지침을 잘 따르더라도, 모두가 동등하게 사용하는데에는 부족하다는데요.실제로 스크린리더기 등으로 들어보니 우리가 의도한 바를 어떤 분들은 알기 어렵구나, 그리고 아리아를 적용하는게 생각보다 어렵진 않겠구나를 느꼈습니다. WAI-ARIA란?접근성이 떨어지기 쉬운 동적 컨텐츠에 접근성을 보완하는 기술입니다. 접근성이 떨어지기 쉬운 부분은?동적인 웹 애플리케이션 접근성 보장을 위한 지침이 부족합니다.Ajax를 통한 실시간 변경 콘텐츠를 못 읽을 수 있습니다.페이지 콘텐츠 중 일부만 변경 시, 동일한 내용을 계속 읽어야 하는 문제가 발생합니다.화면을 확대해서 보는 분들의 경우, 가시범위 밖의 콘텐츠 변경 내용을 알기 어렵습니다.그 외에도 많다고 하네요 ㅜㅜ WAI-ARIA의 목적?마크업에 역할(Role), 속성(Property), 상태(State) 정보를 추가하여스크린 리더 및 보조 기기등에서 접근성 및 상호운용성을 향상시키고보다 나은 사용자경험(UX)을 제공하기 위함 브라우저 지원현황: IE11부터, 대부분의 브라우저가 지원하고 있습니다. WAI-ARIA 사례 바로가기: 야무쌤 포함 여러 전문가들의 노력으로 아리아 사례가 github에 공개되어 있습니다. 세미나 그 후 나의 생각아직 공공기관이나 대기업의 사이트 정도만 웹접근성을 잘 따르려 노력하고 있다고 들었는데, 앞으로는 모두를 위해 천천히라도 적용하였으면 좋겠습니다.웹 접근성을 지키면 사람의 일부가 아니라, 전체에 좋아질거라 생각됩니다.노인을 위한 디자인을 위해, 3년간 노인 분장을 하고 도시를 돌아다녔던 패트리샤 무어의 이야기.. 그 결과 힘이 약한 노인이나 아이들 뿐 아니라, 모두에게 편리한 제품을 디자인할 수 있었습니다.웹, 앱도 다르지 않을거라 생각됩니다. 좋은 서비스에 맞는 좋은 접근성을 제공하여 누구나 쉽고 편리하게 사용하는 서비스를 만들고 싶네요… ^^ 연관 링크W3C의 WAI-ARIA 1.1","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"웹접근성","slug":"Front-End/웹접근성","permalink":"https://sharryhong.github.io/categories/Front-End/웹접근성/"}],"tags":[{"name":"웹접근성","slug":"웹접근성","permalink":"https://sharryhong.github.io/tags/웹접근성/"},{"name":"WAI-ARIA","slug":"WAI-ARIA","permalink":"https://sharryhong.github.io/tags/WAI-ARIA/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"웹접근성","slug":"Front-End/웹접근성","permalink":"https://sharryhong.github.io/categories/Front-End/웹접근성/"}]},{"title":"portfolio-sli.do 서비스 (AngularJS)","slug":"portfolio-slido","date":"2016-12-12T11:23:57.000Z","updated":"2017-09-21T07:47:41.955Z","comments":true,"path":"2016/12/12/portfolio-slido/","link":"","permalink":"https://sharryhong.github.io/2016/12/12/portfolio-slido/","excerpt":"","text":"Hong’s portfolio - sli.do 바로가기Github 소스 바로가기 포트폴리오 주제강의 중 실시간으로 질문, 답변을 받는 서비스 포트폴리오 개발 기간2016-11 ~ 공부하며 코드 리펙토링 중입니다. 특징 및 기능반응형 웹 : 데스크탑, 테블릿, 모바일에 대응하여 적절한 view를 보여줍니다.JSON파일의 data를 불러옵니다. (그룹 이름, 작성자 이름, 질문 내용, 좋아요 개수 등)질문을 입력받아 popular(인기순), Recent(최신순) 대로 보여줍니다.popular(인기순) : 좋아요 버튼 클릭시 자동으로 상단으로 이동합니다.질문자 이름을 입력하지 않을 시 Anonymous(익명)로 표시됩니다.질문 내용을 클릭하면 상세페이지로 이동하여 comment(덧글)를 달 수 있습니다.덧글 개수가 JSON data로 저장되어 main에서 숫자로 보여집니다. 사용 SkillJavaScript, AngularJS, JSON, jQueryHTML, SASS to CSSGulp 주제 선정 이유AngularJS로 서비스를 만들어보고 싶던 중, 생활코딩 세미나에서 sli.do의 서비스를 사용하였습니다.사용이 직관적이어서 좋았고, 강의 중 질문을 바로 올리고, 나중에 강사가 모아서 대답을 할 수 있는 좋은 서비스라 생각되어 개발해보고 싶었습니다. 고려사항comment 기능이 있으면 좋을 것 같아 추가하였습니다.JavaScript prototype Class문법크로스 브라우징 : IE9이상","categories":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Portfolio","slug":"Portfolio/Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/Portfolio/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"https://sharryhong.github.io/tags/AngularJS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/tags/Portfolio/"},{"name":"SASS","slug":"SASS","permalink":"https://sharryhong.github.io/tags/SASS/"},{"name":"Gulp","slug":"Gulp","permalink":"https://sharryhong.github.io/tags/Gulp/"},{"name":"sli.do","slug":"sli-do","permalink":"https://sharryhong.github.io/tags/sli-do/"}],"keywords":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Portfolio","slug":"Portfolio/Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/Portfolio/"}]},{"title":"Grid 시스템을 적용한 Responsive(반응형) Site","slug":"progect-grid-responsive","date":"2016-12-05T08:30:30.000Z","updated":"2017-09-21T07:47:41.982Z","comments":true,"path":"2016/12/05/progect-grid-responsive/","link":"","permalink":"https://sharryhong.github.io/2016/12/05/progect-grid-responsive/","excerpt":"","text":"결과화면 보기 | Github 소스 바로가기 개발 기간2016-07 특징 및 기능그리드 시스템에 따른 반응형 웹데스크탑 대응은 10컬럼, 모바일 대응은 2컬럼 그리드 시스템을 사용하였습니다. 코드 설명grid-responsive.css모바일 대응 : .unit-s-1-2 ~ .unit-s-11-12데스크탑 대응 : .unit-l-1-2 ~ .unit-l-11-12먼저 위같이 class name을 먼저 지정해주고 width를 %단위로 정해줍니다.그 후 html에서 3등분의 경우 class=&quot;unit-s-1-3&quot;로 지정해주면 자동으로 3등분한 style이 적용됩니다. style.css모바일 대응 그리드를 보여주는 부분1234567891011121314151617.show-grid::before &#123; content: &apos;&apos;; position: absolute; z-index: 100; top: 0; left: 0; width: 100%; height: 2165px; background: linear-gradient(90deg, rgba(191, 64, 64, 0.1) 50%, rgba(0,0,0,0.1) 50%), linear-gradient(transparent 95%, #26923f 95%); background-size: // 첫번째 linear-gradient 100%, // 두번째 linear-gradient. 가로 1px, 세로 21px로 채워줍니다. 1px 1.3125rem;&#125; linear-gradient로 그리드를 직접 볼 수 있도록 그려주었습니다.linear-gradient(90deg, rgba(191, 64, 64, 0.1) 50%, rgba(0,0,0,0.1) 50%): x축 그리기. 50%, 50% 간격으로 그리드 색을 지정해줍니다.linear-gradient(transparent 95%, #26923f 95%);: y축 그리기. 95%는 투명색, 5%는 색상을 지정해주어 선을 표시합니다. 데스크탑 대응 그리드를 보여주는 부분1234567@media (min-width: 1000px) &#123; .show-grid::before &#123; background-size: 20% 20%, 1px 1.3125rem; &#125;&#125; linear-gradient 그라이언트 그리드 배경 색상 부분은 모바일 대응과 같아 생략가능하므로 배경 사이즈만 지정하였습니다. Image Responsive-Scale의 예 (이미지 반응형 크기 대응하기)1234567.responsive-scale &#123; width: 100%; padding-bottom: 63%; /*1200/1920 *100*/ background-image: url(&quot;../img/landscape-photos.jpg&quot;); background-size: cover; background-position: center;&#125; padding-bottom: 세로/가로 * 100%;로 해주면 이미지가 반응형으로 대응합니다.","categories":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Portfolio","slug":"Portfolio/Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/Portfolio/"}],"tags":[{"name":"grid","slug":"grid","permalink":"https://sharryhong.github.io/tags/grid/"},{"name":"Responsive","slug":"Responsive","permalink":"https://sharryhong.github.io/tags/Responsive/"},{"name":"반응형","slug":"반응형","permalink":"https://sharryhong.github.io/tags/반응형/"}],"keywords":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Portfolio","slug":"Portfolio/Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/Portfolio/"}]},{"title":"Webpack","slug":"Link-webpack","date":"2016-11-30T14:34:55.000Z","updated":"2017-09-21T07:47:39.605Z","comments":true,"path":"2016/11/30/Link-webpack/","link":"","permalink":"https://sharryhong.github.io/2016/11/30/Link-webpack/","excerpt":"","text":"webpack에 대하여 - 양권성님 블로그webpack 기본 가이드 - HyunSeob님 블로그webpack for Angular+jquery,sass - yamoo9님 github","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://sharryhong.github.io/tags/Webpack/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}]},{"title":"SASS Satting","slug":"sass-satting","date":"2016-11-29T10:07:09.000Z","updated":"2017-09-21T07:47:42.158Z","comments":true,"path":"2016/11/29/sass-satting/","link":"","permalink":"https://sharryhong.github.io/2016/11/29/sass-satting/","excerpt":"","text":"해당 코드가 있는 Github 바로가기 CSS Preprocessor 인 SASS. 웹 스타일링을 담당하는 CSS를 좀 더 똘똘하게 사용하고 유지보수를 좋게하는 프리프로세서입니다. 설치 및 Sass to CSSSass to CSS를 위해 node sass를 실행합니다. 추후엔 Gulp같은 자동화툴로 관리하도록 합니다. 다운로드 및 설치git bash : 터미널 방식으로 명령어를 사용하여서 Git를 컨트롤 하는 시스템설치 후 파일탐색기 &gt; 해당폴더 &gt; 마우스 오른쪽 &gt; git bush here 를 클릭하여 터미널을 실행시킵니다. node sass 설치12$ npm install node-sass --global 혹은$ npm i -g node-sass (install global줄여쓴 것) sass -&gt; css로 sass or scss파일을 만들고 저장 후 1$ node-sass -w sass/ -o css/ --source-map css sass폴더내의 sass or scss 파일을 css폴더내의 css파일로 컴파일한다는 뜻sourcemapping이 있어야 개발자도구에서 style.sass이런식으로 표시가 됩니다. css 폴더내에 xxx.css.map 파일이 생깁니다. 배포시엔 map파일을 제외하고 올립니다. sass파일을 수정 후 저장합니다. 자, 이제 sass -&gt; css파일로 컴파일 되었습니다. 이젠 css파일은 건드리지 않고 sass파일로만 작업합니다. 파일 쪼개고 병합하기예를들어 _footer.sass와 같이 _가 붙으면 병합될 파일이므로 컴파일되지 않습니다.style.sass 에서 @import /part/page/footer 이런 식으로 @import 하여 병합시킵니다.@import시 파일이름의 _, .sass, .scss는 생략할 수 있습니다. Sublime Text에서 sass, scss 파일 인지시키기 Sublime Text의 install package에서 syntax highlighting for sass를 설치합니다. 서브라임 텍스트의 오른쪽 하단에서 sass를 선택합니다. 참고 사이트 Sass-lang.com","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"CSS/SASS","slug":"Front-End/CSS-SASS","permalink":"https://sharryhong.github.io/categories/Front-End/CSS-SASS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://sharryhong.github.io/tags/CSS/"},{"name":"SASS","slug":"SASS","permalink":"https://sharryhong.github.io/tags/SASS/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"CSS/SASS","slug":"Front-End/CSS-SASS","permalink":"https://sharryhong.github.io/categories/Front-End/CSS-SASS/"}]},{"title":"ReactJS ES6","slug":"Link-ReactJS-ES6","date":"2016-11-28T05:13:41.000Z","updated":"2017-09-21T07:47:39.565Z","comments":true,"path":"2016/11/28/Link-ReactJS-ES6/","link":"","permalink":"https://sharryhong.github.io/2016/11/28/Link-ReactJS-ES6/","excerpt":"","text":"ReactJS를 작성할 때에 알아두면 좋은 ES6 문법들 - 고무곰님의 블로그","categories":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sharryhong.github.io/tags/ES6/"}],"keywords":[{"name":"plus forWeb!","slug":"plus-forWeb","permalink":"https://sharryhong.github.io/categories/plus-forWeb/"},{"name":"Bookmark","slug":"plus-forWeb/Bookmark","permalink":"https://sharryhong.github.io/categories/plus-forWeb/Bookmark/"}]},{"title":"JavaScript TabMenu (ES5_prototype class)","slug":"project-javascript-tabmenu","date":"2016-11-28T04:16:12.000Z","updated":"2017-09-21T07:47:42.107Z","comments":true,"path":"2016/11/28/project-javascript-tabmenu/","link":"","permalink":"https://sharryhong.github.io/2016/11/28/project-javascript-tabmenu/","excerpt":"","text":"JavaScript 프로토타입 방식으로 클래스 만들기 - 탭 메뉴 해당 코드가 있는 Github 바로가기 | 결과화면 보기 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 2. 함수 단위 -&gt; 프로토타입 방식 클래스(function(global, $)&#123;&apos;use strict&apos;;// 인스턴스 생성 var tabTab1 = new TabMenu();var tabTab2 = new TabMenu();// 클래스 생성, 프로퍼티 생성function TabMenu() &#123; this.$tab = null this.$tabMenus = null; this.$selectMenu = null;&#125;// 메서드 생성, 요소 초기화 TabMenu.prototype.init =function(el)&#123; this.$tab = $(el); this.$tabMenus = this.$tab.find(&apos;li&apos;); console.log(this);&#125;TabMenu.prototype.initEvent = function()&#123; var objThis = this; // 아래에 설명 추가 this.$tabMenus.on(&quot;click&quot;, function()&#123; objThis.setSelectMenu($(this)); &#125;);&#125;TabMenu.prototype.setSelectMenu = function($thisMenu)&#123; if(this.$selectMenu)&#123; this.$selectMenu.removeClass(&apos;select&apos;); &#125; this.$selectMenu = $thisMenu; this.$selectMenu.addClass(&apos;select&apos;);&#125;tabTab1.init(&apos;#tabMenu1&apos;);tabTab1.initEvent();tabTab2.init(&apos;#tabMenu2&apos;);tabTab2.initEvent();&#125;)(this, this.jQuery); this에 대하여클릭(이벤트) 전 this 는 아래처럼 구성되어 있습니다. (크롬 개발자도구)클래스에 프로퍼티와, prototype에 메서드가 정의되어 있는 걸 볼 수 있습니다. 12345678910TabMenu $selectMenu:null $tab:n.fn.init[1] $tabMenus:n.fn.init[6] __proto__: Object // = prototype constructor:TabMenu() init: function(el) initEvent: function() setSelectMenu: function($thisMenu) __proto__: Object 123456TabMenu.prototype.initEvent = function()&#123; var objThis = this; this.$tabMenus.on(&quot;click&quot;, function()&#123; objThis.setSelectMenu($(this)); &#125;);&#125; 위 코드에서 this.$tabMenus.on(&quot;click&quot;,... 클릭을 하면 this가 클릭한 li요소로 되어버립니다.(이벤트에서 this는 이벤트를 발생시킨 객체이기 때문입니다.)따라서 변수 objThis에 본래의 this를 저장하여 objThis.setSelectMenu($(this));로 사용한 것입니다. 연관 링크JavaScript ES5 Class - 관련 링크 바로가기","categories":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Free Project","slug":"Portfolio/Free-Project","permalink":"https://sharryhong.github.io/categories/Portfolio/Free-Project/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Class","slug":"Class","permalink":"https://sharryhong.github.io/tags/Class/"},{"name":"ES5","slug":"ES5","permalink":"https://sharryhong.github.io/tags/ES5/"},{"name":"prototype","slug":"prototype","permalink":"https://sharryhong.github.io/tags/prototype/"},{"name":"TabMenu","slug":"TabMenu","permalink":"https://sharryhong.github.io/tags/TabMenu/"}],"keywords":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Free Project","slug":"Portfolio/Free-Project","permalink":"https://sharryhong.github.io/categories/Portfolio/Free-Project/"}]},{"title":"JavaScript Class (ES5)","slug":"javascript-class","date":"2016-11-26T13:18:00.000Z","updated":"2017-09-21T07:47:40.439Z","comments":true,"path":"2016/11/26/javascript-class/","link":"","permalink":"https://sharryhong.github.io/2016/11/26/javascript-class/","excerpt":"","text":"완전정복 스터디 3권(웹동네)으로 공부 + 코드 리펙토링 :)해당 코드가 있는 Github 바로가기 Class함수가 특정 알고리즘을 포장하는 기술이라면, 클래스는 연관있는 변수와 함수만을 포장하는 기술입니다.클래스로 포장하는 이유는 객체 단위로 코드를 그룹화 하고 재사용하기 위함입니다. ES6에서는 class가 생겼지만 아직 이전 버전으로 개발을 많이 하고 있습니다. JavaScript에서 클래스처럼 사용할 수 있는 방법으로는 리터럴 방식 함수 방식 프로토타입 방식이 있는데 프로토타입 방식을 선호합니다.이유는 아래에 설명하겠습니다. 개념인스턴스 객체함수를 사용하려면 함수호출을 해야하듯, 클래스를 사용하려면 일반적으로 인스턴스를 생성해야 합니다.클래스 : 설계도, 인스턴스 : 설계도대로 만들어진 결과물 1var 인스턴스 = new 클래스이름(); 인스턴스가 만들어지면 클래스에서 포장해 놓은 프로퍼티와 메서드를 사용할 수 있게 됩니다. 프로퍼티 (변수)주로 객체 내부에서 사용하는 일반적인 정보, 객체 내부 함수(메서드)에서 처리한 결과값 저장 메서드 (함수)주로 객체의 프로퍼티 값을 변경하거나 알아내는 기능, 클래스의 기능들 생성자인스턴스가 만들어지면서 자동으로 호출되는 함수생성자의 주 용도는 프로퍼티 초기화 역할 담당 리터럴 방식으로 클래스 만들기123456789101112var 인스턴스 = &#123; 프로퍼티: 초기 값 // 프로퍼티 정의 ... 메서드: function() &#123; // 메서드 정의 ... &#125;, ...&#125;// 객체 외부에서 접근하기인스턴스.프로퍼티;인스턴스.메서드(); 예 :1$(&quot;p&quot;).css(&quot;color&quot;, &quot;#f00&quot;); $인 함수를 매개변수 값 “p”로 호출$()함수에서 jQuery의 인스턴스를 만들어 리턴해주기 때문에 접근연산자 .를 이용해 jQuery가 제공하는 기능 중 css() 를 호출해 글자색을 변경할 수 있습니다. 특징리터럴 방식에서는 생성자가 존재하지 않습니다.리터럴 방식은 클래스를 정의함과 동시에 자동으로 인스턴스가 만들어집니다.단점 : 인스턴스를 하나만 만들 수 있습니다.주 용도 : 여러 개의 데이터를 묶어 값을 보관하거나 함수의 매개변수 값으로 전달할 때 주로 사용합니다. 123456var $ch = $(&quot;#ch&quot;);$ch.css(&#123; &quot;position&quot;: &quot;absolute&quot;, &quot;top&quot;: 100, &quot;left&quot;: 100&#125;); 함수 방식으로 클래스 만들기1234567891011121314// 일반 함수와 비교하기 위해 클래스이름은 대문자로 시작하도록 한다. (일반적인 규칙)function 클래스이름() &#123; this.프로퍼티 = 초기 값; // 프로퍼티 정의 ... this.메서드 = function() &#123; // 메서드 정의 ... &#125; ...&#125;// 인스턴스 생성var 인스턴스 = new 클래스이름();// 메서드 호출인스턴스.메서드(); 특징생성자 : 클래스이름 자체가 생성자이며 인스턴스가 생성될 때 자동으로 호출됩니다.장점 : 코드 재사용 가능단점 : 인스턴스마다 메서드가 중복해서 생성됩니다. -&gt; 치명적인 단점 프로토타입 방식으로 클래스 만들기클래스를 만드는 방법 중 가장 강력한 방법jQuery도 프로토타입 방식으로 만들어졌다. 1234567891011121314function 클래스이름() &#123; this.프로퍼티 = 초기 값; ...&#125;// 메서드는 prototype이라는 프로퍼티에 정의한다.클래스이름.prototype.메서드 = function() &#123; ...&#125;// 인스턴스 생성var 인스턴스 = new 클래스이름();// 메서드 호출인스턴스.메서드(); 특징코드 재사용모든 인스턴스는 prototype에 만들어져 있는 메서드를 공유해서 사용합니다.자바스크립트에서는 prototype을 이용해 상속을 구현합니다. 연관 링크JavaScript 프로토타입 방식으로 클래스 만들기 실습 - 탭 메뉴 연관 포스팅JavaScript ES6 문법 - class","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Class","slug":"Class","permalink":"https://sharryhong.github.io/tags/Class/"},{"name":"ES5","slug":"ES5","permalink":"https://sharryhong.github.io/tags/ES5/"},{"name":"prototype","slug":"prototype","permalink":"https://sharryhong.github.io/tags/prototype/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://sharryhong.github.io/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","permalink":"https://sharryhong.github.io/categories/Front-End/JavaScript/"}]},{"title":"CSS 속성 선택자를 활용하여 각 파일포맷별 아이콘 설정하기","slug":"project-css-icons","date":"2016-11-26T06:24:43.000Z","updated":"2017-09-21T07:47:42.039Z","comments":true,"path":"2016/11/26/project-css-icons/","link":"","permalink":"https://sharryhong.github.io/2016/11/26/project-css-icons/","excerpt":"","text":"해당 코드가 있는 Github 바로가기 | 결과화면 보기 속성 선택자주로 특수한 상황인 요소를 찾을 때 쓰입니다.[class=&quot;snack&quot;] : classname이 반드시 snack인 요소 선택[class=&quot;snack seeu&quot;] : classname이 반드시 snack seeu인 요소 선택[class*=&quot;snack&quot;] : classname에 snack이 있는 요소 선택[class^=&quot;snack&quot;] : classname이 snack으로 시작하는 요소 선택a[href$=&quot;.docx&quot;] : href 끝나는 값이 .docx인 a요소 선택a[href][title][data-href] : 제시된 3가지 속성을 모두 가지고 있는 a요소 선택 핵심 코드 설명html 파일 123&lt;li class=&quot;lecture-file-item&quot;&gt; &lt;a href=&quot;resources/file.aac&quot;&gt;file-aac&lt;/a&gt;&lt;/li&gt; 다운받을 파일명을 이용하여 background-image를 CSS에 미리 설정해 놓습니다. CSS 파일123456789a[href$=&quot;.aac&quot;] &#123; background-image: url(&quot;../img/icon-aac.png&quot;);&#125;...a[href^=&quot;http://&quot;][target=&quot;_blank&quot;],a[href^=&quot;https://&quot;][target=&quot;_blank&quot;] &#123; background-image: url(&quot;../img/external-link.png&quot;);&#125; ^ 는 처음 값 $ 는 마지막 값 a[href$=&quot;.aac&quot;] : href속성 마지막 값이 .aac인 a요소 선택 연관 링크CSS 선택자에 관한 공부 링크 바로가기","categories":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Free Project","slug":"Portfolio/Free-Project","permalink":"https://sharryhong.github.io/categories/Portfolio/Free-Project/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://sharryhong.github.io/tags/CSS/"},{"name":"선택자","slug":"선택자","permalink":"https://sharryhong.github.io/tags/선택자/"},{"name":"파일 포맷","slug":"파일-포맷","permalink":"https://sharryhong.github.io/tags/파일-포맷/"},{"name":"아이콘","slug":"아이콘","permalink":"https://sharryhong.github.io/tags/아이콘/"}],"keywords":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Free Project","slug":"Portfolio/Free-Project","permalink":"https://sharryhong.github.io/categories/Portfolio/Free-Project/"}]},{"title":"portfolio-선대인경제연구소 사이트","slug":"portfolio-sdi","date":"2016-11-25T06:04:13.000Z","updated":"2017-09-21T07:47:41.921Z","comments":true,"path":"2016/11/25/portfolio-sdi/","link":"","permalink":"https://sharryhong.github.io/2016/11/25/portfolio-sdi/","excerpt":"","text":"Hong’s portfolio - 선대인경제연구소 main 바로가기sub page01 | sub page02-블로그리스트 | sub page03-블로그내용 포트폴리오 개발 기간2015-12 특징 및 기능웹표준, 웹접근성 준수크로스 브라우징 : IE8 이상UI에 초점 사용 SkillHTML, CSS, jQuery, JavaScript, Photoshop 고려사항디비컷 사이트 중 UI, 공부에 도움될 만한 사이트를 선별하여 작업하였습니다.이미지로 되어있는 것을 가능하면 text와 font awesome등으로 만들었습니다. 2016년 12월 현재.. 코드 리펙토링하면 좋을 것들jQuery-UI 라이브러리를 사용한 것을 순수 JavaScript로 개발하면 성능에 더 좋을 것 같습니다.","categories":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Portfolio","slug":"Portfolio/Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/Portfolio/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/tags/Portfolio/"},{"name":"HTML","slug":"HTML","permalink":"https://sharryhong.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://sharryhong.github.io/tags/CSS/"},{"name":"jQuery","slug":"jQuery","permalink":"https://sharryhong.github.io/tags/jQuery/"}],"keywords":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Portfolio","slug":"Portfolio/Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/Portfolio/"}]},{"title":"portfolio-SK 주식회사 사이트","slug":"portfolio-SK","date":"2016-11-25T05:40:43.000Z","updated":"2017-09-21T07:47:41.873Z","comments":true,"path":"2016/11/25/portfolio-SK/","link":"","permalink":"https://sharryhong.github.io/2016/11/25/portfolio-SK/","excerpt":"","text":"Hong’s portfolio - SK 주식회사 main 바로가기sub page01 | sub page02 | sub page03-게시판리스트 | sub page04-게시판내용 포트폴리오 개발 기간2015-11 특징 및 기능반응형 웹 : 데스크탑, 테블릿, 모바일에 대응하여 적절한 view를 보여줍니다.웹표준, 웹접근성 준수크로스 브라우징 : IE8 이상 사용 SkillHTML, CSS, jQuery, JavaScript, Photoshop 고려사항디자인대로 마크업, 의미있는 마크업을 하기 위해 노력하였습니다.개발단계를 고려하여 예상 가능한 부분을 미리 마크업하였습니다.(예 : 게시판의 제목이 길어질 경우)버튼, 게시판 등은 모듈화하여 재사용성을 높였습니다. 2016년 12월 현재.. 코드 리펙토링하면 좋을 것들반응형을 위한 미디어쿼리를 &lt;head&gt;에서 &lt;link media..&gt;로 설정하였는데, 이럴 경우 성능에 좋지 않는 다는 것을 알게되었습니다.이 부분을 css상에서 @media로 코드 리펙토링 하는 게 좋을 것 같습니다.","categories":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Portfolio","slug":"Portfolio/Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/Portfolio/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sharryhong.github.io/tags/JavaScript/"},{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/tags/Portfolio/"},{"name":"HTML","slug":"HTML","permalink":"https://sharryhong.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://sharryhong.github.io/tags/CSS/"},{"name":"jQuery","slug":"jQuery","permalink":"https://sharryhong.github.io/tags/jQuery/"}],"keywords":[{"name":"Portfolio","slug":"Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/"},{"name":"Portfolio","slug":"Portfolio/Portfolio","permalink":"https://sharryhong.github.io/categories/Portfolio/Portfolio/"}]}]}